{"version":3,"sources":["pages/Landing.tsx","../../src/chart/heroElement.ts","../../src/chart/Queue.ts","../../src/chart/DOMPool.ts","../../src/chart/Utils.ts","../../src/chart/webglUtils.ts","../../src/chart/otherTypes.ts","../../src/chart/transformUtils.ts","../../src/chart/domIndependentDrawUtils.ts","../../src/chart/domDependentDrawUtils.ts","../../src/chart/useTrackingRef.ts","../../src/chart/chart.tsx","../../src/chart/usePropsChangeRateLimiter.ts","../../src/chart/fitTextInRectangle.ts","../../src/chart/addTextLayout.ts","../../src/chart/performLayout.ts","../../src/index.tsx","../../src/transformers/treemapCellTransformer.ts","../../src/transformers/mergeComparisonData.ts","../../src/transformers/numberFormatters.ts","pages/ToggleDemo.tsx","pages/DigitDemo.tsx","pages/ComparisonDemo.tsx","App.tsx","index.tsx"],"names":["ListItem","styled","li","to","actuallySendHeroElementTiming","once","heroElementName","window","performance","measures","measure","time","Math","event","hitType","eventCategory","eventLabel","eventAction","nonInteraction","eventValue","ga","timingCategory","timingVar","timingValue","timingLabel","e","console","sendHeroElementTiming","queue","offset","this","length","Error","item","DOMPool","constructor","size","tagName","i","elem","document","failIfValidOrNonExhaustive","_variable","message","ellipsisCharacter","String","UpdateType","PersistentFloat32Array","maxLength","Float32Array","buffer","subarray","theirBuffer","ourBuffer","theirLength","resizeViewport","gl","pixelRatio","canvas","displayWidth","displayHeight","shouldResizeCanvas","compileShader","shader","createProgramFromShaderSource","program","createProgram","vertexShaderSource","fragmentShaderSource","GL_NUM_BYTES_PER_FLOAT","IndexElementType","AttributeLocationRequestType","AttributeBufferRequestType","WebGLVersion","TextLayoutType","applyStyleToDOMNode","domNode","textStyle","NumCellsTier","getColorTripletFromColorString","colorString","unnormalized","color","rectangleReferencePositionValues","rectangleIndices","rectangleIndicesCount","value","ref","useRef","useEffect","Root","normalizedStrokeColor","AnimationStatus","createCellsBuffer","numCellsTier","numCells","setupWebGL","input","canvasRef","current","cellProgramRef","alpha","glInfoRef","vaoExtension","instancedDrawingExtension","cellBuffer","cellsVAO","bindBuffer","bufferDataToBind","rebindBuffer","createPopulatedGLBuffer","rebindGLBuffer","indexBuffer","vertexShader","attributeInfo","attributeName","attributeRequest","location","bufferRequest","createdBuffer","totalSizeAsNumOfFloats","numFloatsPerVertex","stride","thisAttributeInfo","indexSize","indexElementType","dummyDataAsBinary","Uint16Array","indexElementTypeForDrawCall","Uint32Array","indicesBuffer","indexBufferInfo","elementType","uniformLocations","uniformName","result","version","attributes","uniforms","uniformBlockRequests","uniformBlockInfo","assignedBuffer","blockIndex","blockInfo","uniformBlocks","getProgramInfo","fragmentShader","name","type","isInstanced","cellGLBuffer","totalSizeAsNumOfInts","vaoObject","timerExtension","upgradeToLargeBuffer","glInfo","newCellBuffer","performPropsChange","extraInputs","rootEl","rootElRef","cellProgram","prevStatus","statusRef","upgradeBuffer","upgradeToLargeBufferRef","sendHeroElementTimingOnce","sendHeroElementTimingOnceRef","done","prevValue","hasChartSizeChanged","nextValue","inputWidth","chartContainerWidth","prevCells","prevCellsLength","nextCells","prevCell","nextCell","haveCellsChanged","prevKeys","prevTextContainer","prevAttachedDOMNodes","programInfo","sendAttributesToGPUWithVAO","data","sendIndicesToGPUWithVAO","highlighted","cellList","nextKeys","cellListLength","someCellHighlighted","cell","id","x0","y0","x1","y1","isComparisonCell","textLayout","retrievedColor","colorTriplet","desaturate","internalCell","fillColor","strokeOpacity","convertToInternalCells","cells","updatePattern","prevKeysSet","Set","nextKeysSet","getUpdateType","key","inPrev","inNext","prevKeysLength","nextKeysLength","prevKeysPending","pendingKeys","nextKey","lastPendingKey","childMapping","j","prevKey","retrievedPrevKeysPending","retrievedPrevKeyPendingLength","k","pendingPrevKey","pendingKeysLength","m","retrievedPendingKey","getUpdatePattern","cellsInfo","updatePatternLength","actualBuffer","numFloatsPerCellInstance","initialTopLeftX","initialTopLeftY","finalTopLeftX","finalTopLeftY","initialBottomRightX","initialBottomRightY","finalBottomRightX","finalBottomRightY","initialFillColor","finalFillColor","initialStrokeColor","finalStrokeColor","strokeWidth","strokeColor","numFloatsPerCell","numFloatsSetPerInstanceSoFar","instancesCount","writeToCellBuffers","updateGLBuffer","doesNextUpdateHaveData","intervalTrees","xIntervals","yIntervals","xInterval","yInterval","xIntervalTree","createIntervalTree","yIntervalTree","getIntervalTrees","nextXIntervalTree","nextYIntervalTree","tweenTarget","tweenProgress","timeline","paused","childrenNodes","cellWidth","cellHeight","percentageClassName","share","heightAvailableForLabel","label","paddingTop","horizontalPadding","labelElem","pool","className","textContent","top","left","width","height","fontSize","paddingLeft","paddingRight","heightAvailableForPercentage","shareElem","fragment","rootNode","childrenNodesLength","allCurrentlyAttachedDOMNodes","getTextLabelFragment","domPoolRef","textContainerStatus","isTextContainerChanging","prevContainer","nextAttachedDOMNodes","nextContainer","currentAttachedDOMNodes","currentTextContainer","css","opacity","durationInSeconds","onAnimationComplete","endProspChangeTransition","chartContainerHeight","status","currentCells","currentKeys","cellIndicesCount","cellInstancesCount","newAttachedDOMNOdes","newTextContainer","domNodesToRemove","textContainerToRemove","requestAnimationFrame","domPool","prevAttachedDOMNodesLength","animationTween","transitionDuration","ease","onUpdate","onComplete","setupVisibleDraw","performHitTest","chartHeight","mouseClientX","mouseClientY","chartWidth","xTarget","yTarget","xMatchIds","interval","yMatchIds","numXMatches","numYMatches","xId","searchForHits","props","Initial","chartWidthRef","useTrackingRef","chartHeightRef","onMouseOverCellRef","onMouseLeaveChartRef","heightInCSSPixelsRef","widthInCSSPixelsRef","setWidthHeightInCSSPixels","innerGLInfo","isTransitionInProgress","nextValueRef","prevValueRef","isTransitionInProgressRef","onPropsChangeComplete","performNextValueChange","getExtraInputToPropsChangeHandler","usePropsChangeRateLimiter","mouseClientXRef","mouseClientYRef","unthrottledHoverHandler","prevHoveredNode","nextHoveredNode","hoveredNode","onMouseOverCell","onMouseLeaveChart","getUnthrottledHoverHandler","throttledPerformHoverRef","throttle","millisecondsPerSeconds","onMouseLeave","throttledHover","onMouseMove","clientY","throttledPerformHover","onClick","style","attemptFitTextInsideRectangle","fontSizeToTry","maxCharacterHeight","referenceMeasurement","maxCharacterWidth","maxLineNumber","words","text","word","success","lines","fitResult","lineLengthLeft","firstWord","remainingWords","wordToFit","lastFitResult","wordsInLine","wordsBeforeLast","initial","lastWord","last","newWordsBeforeLast","newWords","determineFontSizeToFit","rectangle","totalTextArea","totalRectangleArea","upperBound","lowerBound","layoutAttempt","referenceFontSize","sizeToTry","newUpperBound","newLowerBound","layoutResult","addTextLayout","cellValue","fullWidth","fullHeight","fullAvailableHeightForLabel","labelLayoutWithMargin","measuredCharacterWidth","textSplitIntoLines","line","labelLayout","showText","textUnsplit","useMargin","layoutResultWithoutMargin","truncatedLines","maxCharacterCountToFitWidth","trimmedFirstWord","maxNumOfLines","retainedLines","linesBeforeLast","lastLine","sum","wordsOtherThanLast","newLastWord","newLastLine","truncateTextInRectangle","layoutResultPartialCell","shareLayout","ShowNone","layoutResultFullCell","performLayout","groupedBySection","collection","iteratee","groupByMap","list","topLevelParentId","sortedElemsInSection","sortBy","elemsInSection","elemsWithValue","children","undefined","sectionSum","monetaryValue","firstElem","sectionResult","sectionId","sorted","squarify","rest","transformData","inputs","colorMap","merged","primaryData","d1","d2","secondaryData","secondaryValue","primaryValue","d","createComparisionCells","layoutCell","targetDatum","textCell","primaryCell","comparison","lighten","mergeComparisonData","filteredByMonetaryValue","filterByMonetaryValues","totalSum","transformed","out","title","percentage","withTextLayout","decimalPlaces","format","formatPercentage","datum","measuredCharacterHeight","maxCharacterHeightAtMinFontSize","cellLabel","treeMapCells","tagetColor","c","mergedCells","React","Grid","div","destBostonDataRaw","JSON","parse","forEach","find","push","destBostonData","originBostonDataRaw","originBostonData","employeeBostonDataRaw","cityColorMap","Direction","employeeBostonData","filteredToUSA","filter","filteredBostonData","App","useState","Dest","direction","setDirection","filtered","setFiltered","Origin","Small","onCellClick","log","Container","Nav","nav","Button","button","naicsData","map","naics_id","num_company","toString","parent_id","parseInt","error","transformedData","digit","setDigit","tooltipContent","alert","bostonData","num_employ","industry","newYorkData","comparisonData","display","justifyContent","alignItems","exact","path","component","ToggleDemo","DigitDemo","ComparisonDemo","Landing","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.0cdfcf52.chunk.js","sourcesContent":["import React from 'react';\nimport styled from 'styled-components/macro';\nimport { Link } from 'react-router-dom';\n\nconst ListItem = styled.li`\n  font-size: 1rem;\n  margin-bottom: 0.85rem;\n\n  a {\n    color: rgb(78, 140, 141); \n    text-decoration: none;\n    border-bottom: solid 1px rgb(78, 140, 141);\n  }\n`;\n\nexport default () => {\n  return (\n    <ul>\n      <ListItem><Link to={'/toggle'}>Toggle data demo</Link></ListItem>\n      <ListItem><Link to={'/digit'}>1 - 6 digit demo</Link></ListItem>\n      <ListItem><Link to={'/compare'}>Comparison demo</Link></ListItem>\n    </ul>\n  );\n}\n","import once from 'lodash/once';\n\n// Note: window.HERO_ELEMENT_NAME and window.HERO_ELEMENT_NAMES is defined per\n// route and is set in the HTML document's head: via a template helper:\nconst HERO_ELEMENT_NAME = 'tree map';\nconst measureName = 'hero-element-time';\nconst endMarkerName = 'hero-element-shown';\nconst performanceMetricsGAEventName = 'Performance Metrics';\nconst pageLoadPerformanceMarkerName = 'atlas-page-load';\n\nconst actuallySendHeroElementTiming = once((heroElementName: string) => {\n  if ('performance' in window && performance.mark !== undefined && performance.measure !== undefined) {\n    performance.mark(endMarkerName);\n    (window as any).requestIdleCallback(() => {\n      // Measure and send message only when browser is idle:\n      try {\n        performance.measure(\n          measureName, pageLoadPerformanceMarkerName, endMarkerName,\n        );\n        const measures = performance.getEntriesByName(measureName);\n        if (measures.length > 0) {\n          const measure = measures[0];\n          // Note: can only send integer values:\n          const time = Math.round(measure.duration);\n          const event = {\n            hitType: 'event',\n            eventCategory: performanceMetricsGAEventName,\n            eventLabel: heroElementName,\n            eventAction: 'Hero Element',\n            nonInteraction: true,\n            eventValue: time,\n          };\n\n          const ga = (window as any).ga;\n          ga('send', event);\n          ga('send', {\n            hitType: 'timing',\n            timingCategory: 'load',\n            timingVar: 'Hero Element',\n            timingValue: time,\n            timingLabel: heroElementName,\n          });\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    });\n  }\n});\n\nexport const sendHeroElementTiming = (heroElementName: string) => {\n  if (heroElementName === HERO_ELEMENT_NAME) {\n    actuallySendHeroElementTiming(heroElementName);\n  }\n};\n","// Adapted from http://code.iamkate.com/javascript/queues/.\n\nclass Queue<T> {\n  private queue: T[] = [];\n  private offset = 0;\n\n  getLength() {\n    return this.queue.length - this.offset;\n  }\n\n  isEmpty() {\n    return this.queue.length === 0;\n  }\n\n  enqueue(item: T) {\n    this.queue.push(item);\n  }\n\n  dequeue(): T {\n    let queue = this.queue;\n    let offset = this.offset;\n\n    // if the queue is empty, return immediately\n    if (queue.length === 0) {\n      throw new Error('Cannot dequeue from empty queue');\n    }\n\n    // store the item at the front of the queue\n    const item = queue[offset];\n\n    // increment the offset and remove the free space if necessary\n    if (++ offset * 2 >= queue.length) {\n      queue  = queue.slice(offset);\n      offset = 0;\n    }\n\n    this.queue = queue;\n    this.offset = offset;\n\n    // return the dequeued item\n    return item;\n  }\n\n  /* Returns the item at the front of the queue (without dequeuing it). If the\n   * queue is empty then undefined is returned.\n   */\n  peek(): T {\n    const queue = this.queue;\n    const offset = this.offset;\n\n    if (queue.length <= 0) {\n      throw new Error('Empty queue');\n    }\n\n    return queue[offset];\n  }\n}\n\nexport default Queue;\n","import Queue from './Queue';\n\nexport default class DOMPool {\n  private queue: Queue<HTMLElement> = new Queue<HTMLElement>();\n  constructor(readonly size: number, tagName: string) {\n    const queue = this.queue;\n\n    for (let i = 0; i < size; i += 1) {\n      const elem = document.createElement(tagName);\n      queue.enqueue(elem);\n    }\n  }\n\n  enqueue(elem: HTMLElement) {\n    this.queue.enqueue(elem);\n  }\n\n  dequeue(): HTMLElement {\n    const queue = this.queue;\n    return queue.dequeue();\n  }\n}\n","// Errors out at compile time if a discriminating `switch` doesn't catch all cases\n// of an enum and at run time if for some reason an invalid enum value is passed.\n// See https://basarat.gitbooks.io/typescript/content/docs/types/discriminated-unions.html\nexport function failIfValidOrNonExhaustive(_variable: never, message: string): never {\n  throw new Error(message);\n}\n\nexport const millisecondsPerSeconds = 1_000;\n\nimport {ColorQuadruplet} from './webglUtils';\n\nexport const strokeColor: ColorQuadruplet = [255, 255, 255, 255];\nexport const halfStrokeWidth = 0.5;\n\n// Empirically measured size of character `W` (suposedly the character that\n// takes up the most area) of font \"Source Sans Pro\" at 16px:\nexport const measuredCharacterWidth = 12.3;\nexport const measuredCharacterHeight = 18;\nexport const referenceFontSize = 16;\n\nexport const ellipsisCharacter = String.fromCharCode(0x2026);\n// Like `lodash`'s `groupBy` but the result is an ES6 `Map`\n// instead of an object:\nexport const groupByMap = <Key, Value>(\n  collection: Value[],\n  iteratee: (value: Value) => Key): Map<Key, Value[]> => {\n\n  const result: Map<Key, Value[]> = new Map();\n  collection.forEach(value => {\n    const key = iteratee(value);\n    if (!result.has(key)) {\n      result.set(key, [] as Value[]);\n    }\n    result.get(key)!.push(value);\n  });\n  return result;\n};\n","import {\n  failIfValidOrNonExhaustive,\n} from './Utils';\n\nexport enum UpdateType {\n  Enter = 'Enter',\n  Exit = 'Exit',\n  Update = 'Update',\n}\n\n/* tslint:disable:max-classes-per-file interface-name */\n/* tslint:disable:interface-name */\n// Note: every item of `T` needs to be JSON-serializable\nexport class PersistentArray<T> {\n  data: T[];\n  length: number;\n  constructor(public maxLength: number, initialItem: T) {\n    const stringifiedInitialItem = JSON.stringify(initialItem);\n    const initialData: T[] = [];\n    for (let i = 0; i < maxLength; i += 1) {\n      const item: T = JSON.parse(stringifiedInitialItem);\n      initialData.push(item);\n    }\n    this.length = maxLength;\n    this.data = initialData;\n  }\n\n  // Returns the portion of the array that contains valid information i.e.\n  // excluding \"zeros\" between `this.length` and `this.maxLength`:\n  getMeaningfulData() {\n    return this.data.slice(0, this.length);\n  }\n}\n\n// an array that's intended to not be garbage-collected:\nexport class PersistentFloat32Array {\n  buffer: Float32Array;\n  length: number;\n\n  constructor(public maxLength: number) {\n    this.buffer = new Float32Array(maxLength);\n    this.length = maxLength;\n  }\n\n  // Return the portion of the buffer that contains meaningfully assigned data\n  // (the size of the array buffer is pre-allocated to be always larger than the\n  // size of the actual data it contains).\n  getMeaningfulData(): Float32Array {\n    return this.buffer.subarray(0, this.length);\n  }\n\n  // Copy data from another array (\"they\") of shorter length into this instance (\"we\"):\n  copyFrom(they: PersistentFloat32Array) {\n    const {length: theirLength, buffer: theirBuffer} = they;\n    const {length: ourLength, buffer: ourBuffer} = this;\n    if (theirLength > ourLength) {\n      throw new Error('Not enough space in our array to accommodate data from their array');\n    }\n    for (let i = 0; i < theirLength; i += 1) {\n      ourBuffer[i] = theirBuffer[i];\n    }\n  }\n}\n\n//#region Type definitions for WebGL extensions\nexport interface WebGLTimerQueryEXT {\n  // Fake property to make this type unique:\n  __dummyWebGLTimerQueryEXT: number;\n}\n\nexport interface EXTDisjointTimerQuery {\n  readonly TIME_ELAPSED_EXT: number;\n  readonly QUERY_COUNTER_BITS_EXT: number;\n  readonly CURRENT_QUERY_EXT: number;\n  readonly QUERY_RESULT_EXT: number;\n  readonly QUERY_RESULT_AVAILABLE_EXT: number;\n  readonly TIMESTAMP_EXT: number;\n  readonly GPU_DISJOINT_EXT: number;\n\n  createQueryEXT(): WebGLTimerQueryEXT;\n  beginQueryEXT(num: EXTDisjointTimerQuery['TIME_ELAPSED_EXT'], query: WebGLTimerQueryEXT): void;\n  endQueryEXT(target: number): void;\n  getQueryObjectEXT(query: WebGLTimerQueryEXT, pname: number): any;\n}\n\nexport interface OESElementIndexUint {\n  __dummyOESElementIndexUint: number;\n}\n\nexport interface ANGLEInstancedArrays {\n  readonly VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: number;\n  drawArraysInstancedANGLE(mode: number, first: number, count: number, primcount: number): void;\n  drawElementsInstancedANGLE(mode: number, count: number, type: number, offset: number, primcount: number): void;\n  vertexAttribDivisorANGLE(index: number, divisor: number): void;\n}\n\ninterface WebGLQuery {\n  // Fake property to make this type unique:\n  __dummyWebGLQuery: number;\n}\n\nexport interface EXT_disjoint_timer_query_webgl2 {\n  readonly QUERY_COUNTER_BITS_EXT: number;\n  readonly TIME_ELAPSED_EXT: number;\n  readonly TIMESTAMP_EXT: number;\n  readonly GPU_DISJOINT_EXT: number;\n  queryCounterEXT(query: WebGLQuery, target: number): void;\n  beginQuery(target: number, query?: WebGLQuery): void;\n  endQuery(target: number): void;\n}\n\ndeclare global {\n  interface WebGLRenderingContextBase {\n    getExtension(name: 'EXT_disjoint_timer_query'): EXTDisjointTimerQuery | null;\n  }\n\n  interface WebGL2RenderingContext extends WebGLRenderingContext {\n    // VAO extension:\n    createVertexArray: OES_vertex_array_object['createVertexArrayOES'];\n    deleteVertexArray: OES_vertex_array_object['deleteVertexArrayOES'];\n    isVertexArray: OES_vertex_array_object['isVertexArrayOES'];\n    bindVertexArray: OES_vertex_array_object['bindVertexArrayOES'];\n\n    // Instanced drawing extension:\n    drawArraysInstanced: ANGLE_instanced_arrays['drawArraysInstancedANGLE'];\n    drawElementsInstanced: ANGLE_instanced_arrays['drawElementsInstancedANGLE'];\n    vertexAttribDivisor: ANGLE_instanced_arrays['vertexAttribDivisorANGLE'];\n\n    // Uniform buffer object:\n    getUniformBlockIndex(program: WebGLProgram, uniformBlockName: string): number;\n    uniformBlockBinding(program: WebGLProgram, uniformBlockIndex: number, uniformBlockBinding: number): void;\n    bindBufferBase(target: number, index: number, buffer: WebGLBuffer): void;\n    readonly UNIFORM_BUFFER: number;\n\n    // Query related:\n    createQuery(): WebGLQuery;\n    beginQuery(target: number, query: WebGLQuery): void;\n    endQuery(target: number): WebGLQuery;\n    getQueryParameter(query: WebGLQuery, pname: number): any;\n    readonly QUERY_RESULT_AVAILABLE: number;\n    readonly QUERY_RESULT: number;\n  }\n\n  interface HTMLCanvasElement {\n    getContext(contextId: 'webgl2', contextAttributes?: WebGLContextAttributes): WebGL2RenderingContext | null;\n  }\n}\n//#endregion\n/* tslint:enable:interface-name */\n\nexport type ColorTriplet = [number, number, number];\nexport type ColorQuadruplet = [number, number, number, number];\n\nexport const normalizeColorTriplet = (unnormalized: ColorTriplet): ColorTriplet => ([\n  unnormalized[0] / 255, unnormalized[1] / 255, unnormalized[2] / 255,\n]);\nexport const normalizeColorQuadruplet = (unnormalized: ColorQuadruplet): ColorQuadruplet => ([\n  unnormalized[0] / 255, unnormalized[1] / 255, unnormalized[2] / 255, unnormalized[3] / 255,\n]);\n\nexport const colorTripletToCSSString = (color: ColorTriplet) => `rgb(${color[0]}, ${color[1]}, ${color[2]})`;\n\nexport interface IUpdatePatternItem {\n  key: string;\n  type: UpdateType;\n}\n\n// Adapted from\n// tslint:disable-next-line:max-line-length\n// https://github.com/reactjs/react-transition-group/blob/153d56299903c1d9b85987948dfb410e0e0562e5/src/utils/ChildMapping.js#L39-L83\nexport const getUpdatePattern = (prevKeys: string[], nextKeys: string[]) => {\n  const prevKeysSet = new Set(prevKeys);\n  const nextKeysSet = new Set(nextKeys);\n\n  const getUpdateType = (key: string) => {\n    const inPrev = prevKeysSet.has(key);\n    const inNext = nextKeysSet.has(key);\n    if (inPrev === true && inNext === true) {\n      return UpdateType.Update;\n    } else if (inPrev === true) {\n      return UpdateType.Exit;\n    } else {\n      return UpdateType.Enter;\n    }\n  };\n\n  const prevKeysLength = prevKeys.length;\n  const nextKeysLength = nextKeys.length;\n\n  const prevKeysPending = new Map<string, string[]>();\n\n  let pendingKeys: string[] = [];\n\n  let i = 0;\n  for (i = 0; i < nextKeysLength; i += 1) {\n    const nextKey = nextKeys[i];\n    if (prevKeysSet.has(nextKey)) {\n      if (pendingKeys.length > 0) {\n        prevKeysPending.set(nextKey, pendingKeys);\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(nextKey);\n    }\n  }\n\n  if (pendingKeys.length > 0) {\n    const lastPendingKey = pendingKeys[pendingKeys.length - 1];\n    const index = nextKeys.findIndex(elem => elem === lastPendingKey);\n    if (index < nextKeysLength - 1) {\n      const nextKey = nextKeys[i];\n      prevKeysPending.set(nextKey, pendingKeys);\n      pendingKeys = [];\n    }\n  }\n\n  const childMapping: Map<string, UpdateType> = new Map();\n\n  for (let j = 0; j < prevKeysLength; j += 1) {\n    const prevKey = prevKeys[j];\n    const retrievedPrevKeysPending = prevKeysPending.get(prevKey);\n\n    if (retrievedPrevKeysPending !== undefined) {\n      const retrievedPrevKeyPendingLength = retrievedPrevKeysPending.length;\n      for (let k = 0; k < retrievedPrevKeyPendingLength; k += 1) {\n        const pendingPrevKey = retrievedPrevKeysPending[k];\n        childMapping.set(pendingPrevKey, getUpdateType(pendingPrevKey));\n      }\n    }\n    childMapping.set(prevKey, getUpdateType(prevKey));\n\n  }\n\n  const pendingKeysLength = pendingKeys.length;\n  for (let m = 0; m < pendingKeysLength; m += 1) {\n    const retrievedPendingKey = pendingKeys[m];\n    childMapping.set(retrievedPendingKey, getUpdateType(retrievedPendingKey));\n  }\n\n  const result: IUpdatePatternItem[] = [];\n  for (const [key, type] of (childMapping as any)) {\n    result.push({key, type});\n  }\n\n  return result;\n};\n\nexport const resizeViewport = (gl: WebGLRenderingContext, shouldResizeCanvas: boolean) => {\n  const pixelRatio = window.devicePixelRatio;\n  const canvas = gl.canvas;\n\n  const displayWidth = Math.floor((canvas as any).clientWidth * pixelRatio);\n  const displayHeight = Math.floor((canvas as any).clientHeight * pixelRatio);\n\n  if (shouldResizeCanvas === true) {\n    if (canvas.width !== displayWidth ||\n        canvas.height !== displayHeight) {\n\n        canvas.width = displayWidth;\n        canvas.height = displayHeight;\n    }\n  }\n\n  gl.viewport(0, 0, canvas.width, canvas.height);\n\n};\n\nexport const compileShader = (\n    gl: WebGLRenderingContext, shaderSource: string, shaderType: number,\n  ): WebGLShader => {\n\n  const shader = gl.createShader(shaderType);\n  if (shader === null) {\n    throw new Error('Cannot create shader');\n  }\n  gl.shaderSource(shader, shaderSource);\n  gl.compileShader(shader);\n\n  if (process.env.NODE_ENV !== 'production') {\n    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (success) {\n      return shader;\n    } else {\n      throw new Error('Could not compile shader' + gl.getShaderInfoLog(shader));\n    }\n  }\n\n  return shader;\n\n};\n\nexport const createProgram = (\n    gl: WebGLRenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader,\n  ): WebGLProgram => {\n\n  const program = gl.createProgram();\n  if (program === null) {\n    throw new Error('Cannot create program');\n  }\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  if (process.env.NODE_ENV !== 'production') {\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n    if (success) {\n      return program;\n    } else {\n      throw new Error('Program failed to link: ' + gl.getProgramInfoLog(program));\n    }\n  }\n\n  return program;\n};\n\nexport const createProgramFromShaderSource = (\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n    vertexShaderSource: string,\n    fragmentShaderSource: string,\n  ): WebGLProgram => {\n\n  const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);\n  const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);\n  const program = createProgram(gl, vertexShader, fragmentShader);\n  return program;\n};\n\nexport const sendAttributesToGPUWithVAO = (input: {\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n    programInfo: IProgramInfo,\n    attributeName: string,\n    data: Float32Array,\n  }) => {\n\n  const {\n    gl, data, attributeName,\n    programInfo: {attributes},\n  } = input;\n\n  const info = attributes[attributeName];\n  const buffer = info.buffer;\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferSubData(gl.ARRAY_BUFFER, 0, data);\n};\n\nexport const updateGLBuffer = (input: {\n  gl: WebGLRenderingContext,\n  data: Float32Array,\n  buffer: WebGLBuffer,\n}) => {\n\n  const gl = input.gl;\n  const buffer = input.buffer;\n  const data = input.data;\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferSubData(gl.ARRAY_BUFFER, 0, data);\n};\n\nexport const updateUniformBuffer = (input: {\n    gl: WebGL2RenderingContext,\n    data: Float32Array,\n    buffer: WebGLBuffer,\n  }) => {\n\n  const gl = input.gl;\n  const buffer = input.buffer;\n  const data = input.data;\n\n  gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);\n  gl.bufferSubData(gl.UNIFORM_BUFFER, 0, data);\n};\n\nexport const sendIndicesToGPUWithVAO = (input: {\n    gl: WebGLRenderingContext,\n    programInfo: IProgramInfo\n    data: Uint16Array | Uint32Array,\n  }) => {\n\n  const {\n    gl, data,\n    programInfo: {indexBuffer},\n  } = input;\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer.buffer);\n  gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, data);\n};\n\n// There are 4 bytes in a 32-bit float:\nexport const GL_NUM_BYTES_PER_FLOAT = Float32Array.BYTES_PER_ELEMENT;\n\ninterface IAttributeInfo {\n  location: number;\n  buffer: WebGLBuffer;\n  numFloatsPerVertex: number;\n  stride: number; // in bytes\n  offset: number; // in bytes\n}\n\n// Whether the index buffer allows 16-bit or 32-bit elements:\nexport enum IndexElementType {\n  Int16,\n  Int32,\n}\n\ntype IIndexBufferInfo = {\n  buffer: WebGLBuffer;\n  // Either gl.UNSIGNED_SHORT (16 bit) or gl.UNSIGNED_INT (32 bit)\n  elementType: number;\n};\n\ninterface IUniformBlockInfo {\n  buffer: WebGLBuffer;\n}\n\nexport type IProgramInfo = {\n  program: WebGLProgram;\n  attributes: Record<string, IAttributeInfo>;\n  uniforms: Record<string, WebGLUniformLocation>;\n  indexBuffer: IIndexBufferInfo;\n} & (\n  {version: WebGLVersion.One} |\n  {version: WebGLVersion.Two; uniformBlocks: Record<string, IUniformBlockInfo>}\n);\n\n// `Implicit` means we let WebGL assign the attribute location automatically.\n// `Explicit` means we manually assign a location:\nexport enum AttributeLocationRequestType {\n  Implicit,\n  Explicit,\n}\n\nexport enum AttributeBufferRequestType {\n  Implicit,\n  Explicit,\n}\n\ntype AttributeBufferRequest = {\n  type: AttributeBufferRequestType.Implicit\n  totalSizeAsNumOfFloats: number; // Max num of floats that can fit into this buffer.\n} | {\n  type: AttributeBufferRequestType.Explicit;\n  buffer: WebGLBuffer;\n};\n\nexport interface IAttributeRequest {\n  name: string;\n  // How many floats should be pulled out of this buffer per vertex\n  // e.g. if the attribute is a `vec2`, this number shoudl be 2:\n  numFloatsPerVertex: number;\n  stride: number; // in bytes\n  offset: number; // in bytes\n  buffer: AttributeBufferRequest;\n  isInstanced: boolean;\n}\n\nexport interface IIndexRequest {\n  // Max size of integers (16 or 32 bit) that can fit into the buffer:\n  totalSizeAsNumOfInts: number;\n  elementType: IndexElementType;\n}\n\nexport const createPopulatedGLBuffer = (\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n    bufferData: PersistentFloat32Array) => {\n  const buffer = gl.createBuffer();\n  if (buffer === null) {\n    throw new Error('Cannot create WebGL buffer');\n  }\n\n  const bindBuffer = (bufferDataToBind: PersistentFloat32Array) => {\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, bufferDataToBind.buffer, gl.STATIC_DRAW);\n  };\n  bindBuffer(bufferData);\n\n  return {\n    buffer,\n    rebindBuffer: bindBuffer,\n  };\n};\n\nexport enum WebGLVersion {\n  One,\n  Two,\n}\n\nexport interface IUniformBlockRequest {\n  name: string;\n  assignedBlockIndex: number;\n  assignedBuffer: WebGLBuffer;\n}\n\ntype GetProgramInfoInput = {\n  vertexShader: string,\n  fragmentShader: string,\n  attributes: IAttributeRequest[],\n  uniforms: string[],\n  indexBuffer: IIndexRequest,\n  vaoObject: WebGLVertexArrayObjectOES,\n} & (\n  {\n    version: WebGLVersion.One,\n    gl: WebGLRenderingContext,\n    vaoExtension: OES_vertex_array_object,\n    instancedDrawingExtension: ANGLE_instanced_arrays,\n  } | {\n    version: WebGLVersion.Two,\n    gl: WebGL2RenderingContext,\n    uniformBlocks: IUniformBlockRequest[];\n  }\n);\n\nexport const getProgramInfo = (input: GetProgramInfoInput): IProgramInfo => {\n\n  const {\n    gl, vertexShader, fragmentShader, attributes, uniforms, indexBuffer,\n  } = input;\n\n  const program = createProgramFromShaderSource(gl, vertexShader, fragmentShader);\n\n  if (input.version === WebGLVersion.One) {\n    input.vaoExtension.bindVertexArrayOES(input.vaoObject);\n  } else if (input.version === WebGLVersion.Two) {\n    input.gl.bindVertexArray(input.vaoObject);\n  } else {\n    failIfValidOrNonExhaustive(input, 'Invalid version');\n  }\n\n  // Pre-allocate buffer size for attributes:\n  const attributeInfo: Record<string, IAttributeInfo> = {};\n  for (const attributeRequest of attributes) {\n    const attributeName = attributeRequest.name;\n    const location = input.gl.getAttribLocation(program, attributeName);\n\n    const bufferRequest = attributeRequest.buffer;\n    let buffer: WebGLBuffer;\n    if (bufferRequest.type === AttributeBufferRequestType.Implicit) {\n      const createdBuffer = gl.createBuffer();\n      if (createdBuffer === null) {\n        throw new Error('Cannot create buffer for attribute ' + attributeName);\n      }\n      buffer = createdBuffer;\n      const totalSizeAsNumOfFloats = bufferRequest.totalSizeAsNumOfFloats;\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(totalSizeAsNumOfFloats), gl.STATIC_DRAW);\n    } else {\n      buffer = bufferRequest.buffer;\n      // Still need to bind buffer so that `vertexAttribPointer` points to the right buffer:\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    }\n\n    const numFloatsPerVertex = attributeRequest.numFloatsPerVertex;\n    const stride = attributeRequest.stride;\n    const offset = attributeRequest.offset;\n\n    // Need this step because a \"no buffer selected\" error will be generated if\n    // this attribute is enabled but not bound to any buffer through\n    // `bindBuffer`/`vertextAttribPointer` by the time of the first\n    // `gl.drawArrays` or `gl.drawElements` call. See\n    // https://bugs.webkit.org/show_bug.cgi?id=40315\n    gl.enableVertexAttribArray(location);\n\n    gl.vertexAttribPointer(location, numFloatsPerVertex, gl.FLOAT, false, stride, offset);\n\n    if (attributeRequest.isInstanced === true) {\n      if (input.version === WebGLVersion.One) {\n        input.instancedDrawingExtension.vertexAttribDivisorANGLE(location, 1);\n      } else if (input.version === WebGLVersion.Two) {\n        input.gl.vertexAttribDivisor(location, 1);\n      } else {\n        failIfValidOrNonExhaustive(input, 'Invalid version');\n      }\n    }\n\n    const thisAttributeInfo: IAttributeInfo = {\n      location, buffer, numFloatsPerVertex, stride, offset,\n    };\n\n    attributeInfo[attributeName] = thisAttributeInfo;\n  }\n\n  // Pre-allocate buffer space for index:\n  const indexSize = indexBuffer.totalSizeAsNumOfInts;\n  const indexElementType = indexBuffer.elementType;\n\n  let dummyDataAsBinary: Uint16Array | Uint32Array;\n  let indexElementTypeForDrawCall: number;\n  if (indexElementType === IndexElementType.Int16) {\n    dummyDataAsBinary = new Uint16Array(indexSize);\n    indexElementTypeForDrawCall = gl.UNSIGNED_SHORT;\n  } else if (indexElementType === IndexElementType.Int32) {\n    dummyDataAsBinary = new Uint32Array(indexSize);\n    indexElementTypeForDrawCall = gl.UNSIGNED_INT;\n  } else {\n    failIfValidOrNonExhaustive(indexElementType, 'Invalid index element type');\n    // Following lines will never be executed:\n    dummyDataAsBinary = undefined as any;\n    indexElementTypeForDrawCall = 0;\n  }\n  const indicesBuffer = gl.createBuffer();\n  if (indicesBuffer === null) {\n    throw new Error('Cannot create indices buffer');\n  }\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, dummyDataAsBinary, gl.STATIC_DRAW);\n  const indexBufferInfo: IIndexBufferInfo = {\n    elementType: indexElementTypeForDrawCall, buffer: indicesBuffer,\n  };\n\n  if (input.version === WebGLVersion.One) {\n    input.vaoExtension.bindVertexArrayOES(null as any);\n  } else if (input.version === WebGLVersion.Two) {\n    input.gl.bindVertexArray(null as any);\n  } else {\n    failIfValidOrNonExhaustive(input, 'Invalid version');\n  }\n\n  const uniformLocations: Record<string, WebGLUniformLocation> = {};\n  for (const uniformName of uniforms) {\n    const location = gl.getUniformLocation(program, uniformName);\n    if (location === null) {\n      throw new Error('Error getting location of uniform variable ' + uniformName + '. ' + gl.getError());\n    }\n    uniformLocations[uniformName] = location;\n  }\n\n  let result: IProgramInfo;\n  if (input.version === WebGLVersion.One) {\n    result = {\n      version: WebGLVersion.One,\n      program,\n      attributes: attributeInfo,\n      uniforms: uniformLocations,\n      indexBuffer: indexBufferInfo,\n    };\n  } else if (input.version === WebGLVersion.Two) {\n\n    const uniformBlockRequests = input.uniformBlocks;\n    const uniformBlockInfo: Record<string, IUniformBlockInfo> = {};\n    for (const {name, assignedBlockIndex, assignedBuffer} of uniformBlockRequests) {\n      // See https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object#OpenGL_Usage\n      const blockIndex = input.gl.getUniformBlockIndex(program, name);\n      input.gl.uniformBlockBinding(program, blockIndex, assignedBlockIndex);\n      input.gl.bindBuffer(input.gl.UNIFORM_BUFFER, assignedBuffer);\n      input.gl.bindBufferBase(input.gl.UNIFORM_BUFFER, assignedBlockIndex, assignedBuffer);\n      const blockInfo: IUniformBlockInfo = {\n        buffer: assignedBuffer,\n      };\n      uniformBlockInfo[name] = blockInfo;\n    }\n    result = {\n      version: WebGLVersion.Two,\n      program,\n      attributes: attributeInfo,\n      uniforms: uniformLocations,\n      indexBuffer: indexBufferInfo,\n      uniformBlocks: uniformBlockInfo,\n    };\n  } else {\n    failIfValidOrNonExhaustive(input, 'Invalid version');\n    // These lines will never be executed:\n    result = undefined as any;\n  }\n\n  return result;\n};\n\ntype IMeasureGPUTimeOptions = {\n  description: string,\n} & (\n  {\n    version: WebGLVersion.One;\n    gl: WebGLRenderingContext;\n    timerExtension: EXTDisjointTimerQuery\n  } | {\n    version: WebGLVersion.Two;\n    gl: WebGL2RenderingContext;\n    timerExtension: EXT_disjoint_timer_query_webgl2;\n  }\n);\nexport const measureGPUTime = (\n    options: IMeasureGPUTimeOptions,\n    drawFunction: () => void,\n    // This is needed because time measurement result isn't available right away:\n    reportingDelay = 1_000) => {\n\n  if (process.env.NODE_ENV === 'production') {\n    drawFunction();\n  } else {\n    if (options.timerExtension === null) {\n      console.warn('timer extension is not defined');\n      drawFunction();\n    } else {\n\n      type StoredQuery = {\n        version: WebGLVersion.One;\n        query: WebGLTimerQueryEXT;\n        timerExtension: EXTDisjointTimerQuery;\n        gl: WebGLRenderingContext;\n      } | {\n        version: WebGLVersion.Two;\n        query: WebGLQuery;\n        timerExtension: EXT_disjoint_timer_query_webgl2;\n        gl: WebGL2RenderingContext;\n      };\n\n      let storedQuery: StoredQuery;\n      if (options.version === WebGLVersion.One) {\n        const timerExtension = options.timerExtension;\n        const query =  timerExtension.createQueryEXT();\n        storedQuery = {\n          version: WebGLVersion.One,\n          query,\n          timerExtension,\n          gl: options.gl,\n        };\n        timerExtension.beginQueryEXT(timerExtension.TIME_ELAPSED_EXT, query);\n      } else {\n        const timerExtension = options.timerExtension!;\n        const gl = options.gl;\n        const query = gl.createQuery();\n        storedQuery = {\n          version: WebGLVersion.Two,\n          query,\n          timerExtension,\n          gl: options.gl,\n        };\n        gl.beginQuery(timerExtension.TIME_ELAPSED_EXT, query);\n      }\n\n      drawFunction();\n\n      const description = options.description;\n\n      if (storedQuery.version === WebGLVersion.One) {\n        const timerExtension = storedQuery.timerExtension;\n        const query = storedQuery.query;\n        const gl = storedQuery.gl;\n\n        storedQuery.timerExtension.endQueryEXT(storedQuery.timerExtension.TIME_ELAPSED_EXT);\n\n        setTimeout(() => {\n          const available = timerExtension.getQueryObjectEXT(query!, timerExtension.QUERY_RESULT_AVAILABLE_EXT);\n          const disjoint = gl.getParameter(timerExtension.GPU_DISJOINT_EXT);\n\n          if (available && !disjoint) {\n            // See how much time the rendering of the object took in nanoseconds.\n            const timeElapsed = timerExtension.getQueryObjectEXT(query!, timerExtension.QUERY_RESULT_EXT);\n\n            console.info('timeElapsed for', description, ':', timeElapsed / 1_000_000, 'ms');\n          }\n        }, reportingDelay);\n\n      } else {\n        const timerExtension = storedQuery.timerExtension;\n        const query = storedQuery.query;\n        const gl = storedQuery.gl;\n        gl.endQuery(timerExtension.TIME_ELAPSED_EXT);\n\n        setTimeout(() => {\n          const available = gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE);\n          const disjoint = gl.getParameter(timerExtension.GPU_DISJOINT_EXT);\n\n          if (available && !disjoint) {\n            const timeElapsed = gl.getQueryParameter(query, gl.QUERY_RESULT);\n            console.info('timeElapsed for', description, ':', timeElapsed / 1_000_000, 'ms');\n          }\n\n        }, reportingDelay);\n      }\n\n    }\n  }\n};\n","export interface ITreeMapCell {\n  // Key used to manage transition animations between different tree maps. No\n  // two cells across all possible different tree maps should have the same\n  // `uniqueKey`:\n  id: string;\n  // Monetary value of a cell:\n  value: number;\n\n  color: string;\n\n  x0: number;\n  y0: number;\n  x1: number;\n  y1: number;\n\n  // info about where and how cell label should be displayed:\n  textLayout: TextLayout;\n\n  // optional info on whether this cell is a comparison or not\n  comparison?: boolean;\n}\n\n// Layout for percentage numbers in each cell:\nexport type ShareLayout  = {\n  showText: false,\n} | {\n  showText: true;\n  fontSize: number;\n  text: string;\n};\n\nexport type LabelLayout = {\n  showText: false,\n} | {\n  showText: true,\n  fontSize: number;\n  useMargin: boolean;\n  // `textSplitIntoLines` are broken into separate lines for use in SVG which\n  // does not support text wrapping. `textUnsplit` is used in DOM:\n  textSplitIntoLines: string[]\n  textUnsplit: string;\n};\n// (for smaller cells) 3) no label at all (cells that are too small).\nexport enum TextLayoutType {\n  ShowBoth = 'ShowBoth',\n  ShowOnlyShare = 'ShowOnlyShare',\n  ShowNone = 'ShowNone',\n}\n// 3 types of tree map cell labels. If there's enough space, we show both the\n// label and percentage. If there's not enough space for a label for enough for\n// a percentage, we show only the percentage. Otherwise, show nothing:\nexport type TextLayout = {\n  type: TextLayoutType.ShowBoth;\n  label: LabelLayout;\n  share: ShareLayout;\n} | {\n  type: TextLayoutType.ShowOnlyShare;\n  share: ShareLayout;\n} | {\n  type: TextLayoutType.ShowNone,\n};\n","import {\n  measuredCharacterHeight,\n  referenceFontSize,\n} from './Utils';\n\ninterface IWithExportImport {\n  value: number | null;\n}\n\ntype ComputedDatum<T extends IWithExportImport> = Omit<T, 'value'> & {monetaryValue: number};\n\nexport const computeGrossNetTradeValues = <T extends IWithExportImport>(\n    input: T[]\n  ): Array<ComputedDatum<T>> => {\n\n  let result: Array<ComputedDatum<T>> = input.map(\n    ({value, ...rest}) => {\n      const monetaryValue = value ? value : 0;\n      return {monetaryValue, ...rest};\n    },\n  );\n  return result;\n};\n\ninterface IWithMonetaryValue {\n  monetaryValue: number;\n}\nexport const filterByMonetaryValues =\n  <T extends IWithMonetaryValue>(data: T[]): T[] =>\n    data.filter(({monetaryValue}) => monetaryValue > 0);\n\n//#region Constants\n// The font size should never get smaller than this:\nexport const minNodeNameFontSize = 8;\nexport const labelHorizontalMargin = 0.05; // in percentage points i.e. the number '5' means '5%'\nexport const labelTopMargin = 0.05; // in percentage points\nexport const heightProportionReservedForShare = 0.2; // in percentage points\n\nexport const maxCharacterHeightAtMinFontSize = measuredCharacterHeight / referenceFontSize * minNodeNameFontSize;\n//#endregion\n","import color from 'color';\nimport intervalTreeDefaultExport, {\n  Interval,\n  IntervalTree,\n} from 'interval-tree-1d';\nimport {\n  desaturate,\n} from 'polished';\nimport {\n  ColorQuadruplet,\n  ColorTriplet,\n  IUpdatePatternItem,\n  normalizeColorTriplet,\n  PersistentFloat32Array,\n  UpdateType,\n} from './webglUtils';\nimport {\n  failIfValidOrNonExhaustive,\n} from './Utils';\nimport {\n  ITreeMapCell,\n  TextLayout,\n} from './otherTypes';\n\nexport enum NumCellsTier {\n  // Use `Small` for all type of tree maps except for product tree maps at\n  // 6-digit detail level:\n  Small,\n  Large,\n}\n\nexport const transitionDuration = 350; // in ms;\n\nexport interface ICellInternal {\n  id: string;\n  fillColor: ColorQuadruplet;\n  strokeOpacity: number;\n  x0: number;\n  y0: number;\n  x1: number;\n  y1: number;\n  textLayout: TextLayout;\n  isComparisonCell: boolean;\n}\n\nconst getColorTripletFromColorString =\n  (colorString: string) => normalizeColorTriplet(color(colorString).rgb().array() as ColorTriplet);\n\nexport const convertToInternalCells =\n  (cellList: ITreeMapCell[], highlighted: string | undefined) => {\n\n  const nextCells: Map<string, ICellInternal> = new Map();\n  const nextKeys: string[] = [];\n\n  const cellListLength = cellList.length;\n  const someCellHighlighted = (highlighted !== undefined);\n  for (let i = 0; i < cellListLength; i += 1) {\n    const cell = cellList[i];\n    const id = cell.id;\n    const x0 = cell.x0;\n    const y0 = cell.y0;\n    const x1 = cell.x1;\n    const y1 = cell.y1;\n    const isComparisonCell = cell.comparison ? true : false;\n    const textLayout = cell.textLayout;\n    const retrievedColor = cell.color;\n\n    const colorTriplet: ColorTriplet = (someCellHighlighted && highlighted !== id) ?\n                                        getColorTripletFromColorString(desaturate(0.3, retrievedColor)) :\n                                        getColorTripletFromColorString(retrievedColor);\n    const colorQuadruplet = [colorTriplet[0], colorTriplet[1], colorTriplet[2], 1] as ColorQuadruplet;\n    const internalCell: ICellInternal = {\n      id, x0, y0, x1, y1, textLayout,\n      fillColor: colorQuadruplet,\n      strokeOpacity: 1,\n      isComparisonCell,\n    };\n    nextKeys.push(id);\n    nextCells.set(id, internalCell);\n  }\n  return {\n    nextCells, nextKeys,\n  };\n};\n\nexport const rectangleReferencePositionValues = [\n  // top left:\n  1, 1,\n  // top right:\n  0, 1,\n  // bottom right:\n  0, 0,\n  // bottom left:\n  1, 0,\n];\n\nexport const rectangleIndices = [\n  1, 0, 2,\n  2, 0, 3,\n];\nexport const rectangleIndicesCount = rectangleIndices.length;\n\nexport const numFloatsPerCellInstance = 17;\n\nexport const writeToCellBuffers = (\n    prevCells: Map<string, ICellInternal>,\n    nextCells: Map<string, ICellInternal>,\n    updatePattern: IUpdatePatternItem[],\n    halfStrokeWidth: number,\n    strokeColor: ColorQuadruplet,\n    cellBuffer: PersistentFloat32Array,\n  ) => {\n\n  const updatePatternLength = updatePattern.length;\n\n  const numInstancesPerCell = 2;\n  const actualBuffer = cellBuffer.buffer;\n  const numFloatsPerCell = numFloatsPerCellInstance * numInstancesPerCell;\n  cellBuffer.length = updatePatternLength * numFloatsPerCell;\n\n  for (let i = 0; i < updatePatternLength; i += 1) {\n    const {key, type} = updatePattern[i];\n    let initialTopLeftX: number, initialTopLeftY: number;\n    let finalTopLeftX: number, finalTopLeftY: number;\n    let initialBottomRightX: number, initialBottomRightY: number;\n    let finalBottomRightX: number, finalBottomRightY: number;\n    let initialFillColor: ColorQuadruplet, finalFillColor: ColorQuadruplet;\n    let initialStrokeColor: ColorQuadruplet, finalStrokeColor: ColorQuadruplet;\n    let strokeWidth: number;\n\n    if (type === UpdateType.Enter) {\n      const cell = nextCells.get(key)!;\n      initialTopLeftX = finalTopLeftX = cell.x0;\n      initialTopLeftY = finalTopLeftY = cell.y0;\n      initialBottomRightX = finalBottomRightX = cell.x1;\n      initialBottomRightY = finalBottomRightY = cell.y1;\n\n      const {fillColor, isComparisonCell} = cell;\n      initialFillColor = fillColor.slice(0) as ColorQuadruplet;\n      initialFillColor[3] = 0;\n      finalFillColor = fillColor.slice(0) as ColorQuadruplet;\n\n      initialStrokeColor = strokeColor.slice(0) as ColorQuadruplet;\n      initialStrokeColor[3] = 0;\n      finalStrokeColor = strokeColor.slice(0) as ColorQuadruplet;\n      strokeWidth = isComparisonCell ? 0 : halfStrokeWidth;\n\n    } else if (type === UpdateType.Exit) {\n      const cell = prevCells.get(key)!;\n      initialTopLeftX = finalTopLeftX = cell.x0;\n      initialTopLeftY = finalTopLeftY = cell.y0;\n      initialBottomRightX = finalBottomRightX = cell.x1;\n      initialBottomRightY = finalBottomRightY = cell.y1;\n\n      const {fillColor, strokeOpacity, isComparisonCell} = cell;\n\n      initialFillColor = fillColor.slice(0) as ColorQuadruplet;\n      finalFillColor = fillColor.slice(0) as ColorQuadruplet;\n      finalFillColor[3] = 0;\n\n      initialStrokeColor = strokeColor.slice(0) as ColorQuadruplet;\n      initialStrokeColor[3] = strokeOpacity;\n      finalStrokeColor = strokeColor.slice(0) as ColorQuadruplet;\n      finalStrokeColor[3] = 0;\n      strokeWidth = isComparisonCell ? 0 : halfStrokeWidth;\n\n    } else if (type === UpdateType.Update) {\n      const prevCell = prevCells.get(key)!;\n      const nextCell = nextCells.get(key)!;\n      ({\n        x0: initialTopLeftX, y0: initialTopLeftY, x1: initialBottomRightX, y1: initialBottomRightY,\n        /* tslint:disable-next-line:trailing-comma */\n        fillColor: initialFillColor\n      } = prevCell);\n      ({\n        x0: finalTopLeftX, y0: finalTopLeftY, x1: finalBottomRightX, y1: finalBottomRightY,\n        /* tslint:disable-next-line:trailing-comma */\n        fillColor: finalFillColor\n      } = nextCell);\n\n      initialStrokeColor = strokeColor.slice(0) as ColorQuadruplet;\n      initialStrokeColor[3] = prevCell.strokeOpacity;\n\n      finalStrokeColor = strokeColor.slice(0) as ColorQuadruplet;\n      finalStrokeColor[3] = nextCell.strokeOpacity;\n      strokeWidth = halfStrokeWidth;\n\n    } else {\n      failIfValidOrNonExhaustive(type, 'Invalid update type');\n      // These lines will never execute:\n      initialTopLeftX = finalTopLeftX = 0;\n      initialTopLeftY = finalTopLeftY = 0;\n      initialBottomRightX = finalBottomRightX = 0;\n      initialBottomRightY = finalBottomRightY = 0;\n      initialFillColor = finalFillColor = [0, 0, 0, 0];\n      initialStrokeColor = finalStrokeColor = [0, 0, 0, 0];\n      strokeWidth = halfStrokeWidth;\n    }\n\n    // Add the position values twice because they are shared by the fill and stroke rectangles:\n    for (let j = 0; j < numFloatsPerCellInstance; j += 1) {\n      // initialTopLeft\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j] = initialTopLeftX;\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j + 1] = initialTopLeftY;\n\n      // finalTopLeft\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j + 2] = finalTopLeftX;\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j + 3] = finalTopLeftY;\n\n      // initialBottomRight:\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j + 4] = initialBottomRightX;\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j + 5] = initialBottomRightY;\n\n      // finalBottomRight:\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j + 6] = finalBottomRightX;\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j + 7] = finalBottomRightY;\n    }\n\n    let numFloatsSetPerInstanceSoFar = 8;\n\n    // Assign stroke color to first instance:\n    for (let k = 0; k < 4; k += 1) {\n      actualBuffer[numFloatsPerCell * i + numFloatsSetPerInstanceSoFar + k] = initialStrokeColor[k];\n      actualBuffer[numFloatsPerCell * i + numFloatsSetPerInstanceSoFar + 4 + k] = finalStrokeColor[k];\n    }\n\n    // Assign fill color to second instance:\n    for (let m = 0; m < 4; m += 1) {\n      actualBuffer[\n        numFloatsPerCell * i + numFloatsPerCellInstance + numFloatsSetPerInstanceSoFar + m\n      ] = initialFillColor[m];\n      actualBuffer[\n        numFloatsPerCell * i + numFloatsPerCellInstance + numFloatsSetPerInstanceSoFar + 4 + m\n      ] = finalFillColor[m];\n    }\n\n    numFloatsSetPerInstanceSoFar = 16;\n    // Set `halfStrokeWidth` to 0 for first instance (stroke):\n    actualBuffer[numFloatsPerCell * i + numFloatsSetPerInstanceSoFar] = 0;\n    // Set `halfStrokeWidth` to `halfStrokeWidth` for first instance (fill):\n    actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance + numFloatsSetPerInstanceSoFar] = strokeWidth;\n  }\n\n  return {\n    instancesCount: updatePatternLength * 2,\n  };\n};\n\nexport const getIntervalTrees = (\n    nextKeys: string[],\n    nextCells: Map<string, ICellInternal>,\n    // Need to do this because doing this\n    // `import createIntervalTree from 'interval-tree-1d`\n    // works in TypeScript but not in jest so we need to import the module separately\n    // in the typescript and jest worlds.\n    // TODO: figure out why there's discrepancy between how jest and typescript produces\n    // different import calls\n    createIntervalTree: typeof intervalTreeDefaultExport,\n  ) => {\n\n  const nextKeysLength = nextKeys.length;\n  const xIntervals: Array<Interval<string>> = [];\n  const yIntervals: Array<Interval<string>> = [];\n  for (let i = 0; i < nextKeysLength; i += 1) {\n    const cell = nextCells.get(nextKeys[i])!;\n    const id = cell.id;\n    const x0 = cell.x0;\n    const y0 = cell.y0;\n    const x1 = cell.x1;\n    const y1 = cell.y1;\n\n    const xInterval: Interval<string> = [x0, x1, id];\n    const yInterval: Interval<string> = [y0, y1, id];\n    xIntervals.push(xInterval);\n    yIntervals.push(yInterval);\n  }\n\n  return {\n    xIntervalTree: createIntervalTree(xIntervals),\n    yIntervalTree: createIntervalTree(yIntervals),\n  };\n};\n\nexport const searchForHits = (\n    xIntervalTree: IntervalTree<string>,\n    yIntervalTree: IntervalTree<string>,\n    xMax: number,\n    yMax: number,\n    xTarget: number,\n    yTarget: number,\n  ) => {\n\n  if (xTarget < 0 || xTarget > xMax || yTarget < 0 || yTarget > yMax) {\n    return undefined;\n  }  else {\n    const xMatchIds: string[] = [];\n    xIntervalTree.queryPoint(xTarget, (interval: Interval<string>) => {\n      xMatchIds.push(interval[2]);\n      return undefined;\n    });\n\n    const yMatchIds: string[] = [];\n    yIntervalTree.queryPoint(yTarget, (interval: Interval<string>) => {\n      yMatchIds.push(interval[2]);\n      return undefined;\n    });\n\n    const numXMatches = xMatchIds.length;\n    const numYMatches = yMatchIds.length;\n\n    for (let i = 0; i < numXMatches; i += 1) {\n      const xId = xMatchIds[i];\n      for (let j = 0; j < numYMatches; j += 1) {\n        const yId = yMatchIds[j];\n        if (xId === yId) {\n          return xId;\n        }\n      }\n    }\n    return undefined;\n  }\n};\n","import Pool from './DOMPool';\nimport {\n  IUpdatePatternItem,\n  UpdateType,\n} from './webglUtils';\nimport {\n  ICellInternal,\n} from './domIndependentDrawUtils';\nimport {\n  TextLayoutType,\n} from './otherTypes';\nimport {\n  heightProportionReservedForShare,\n  labelHorizontalMargin,\n  labelTopMargin,\n} from './transformUtils';\n\ninterface ITextElemStyles {\n  className: string;\n  textContent: string;\n  top: string;\n  left: string;\n  width: string;\n  height: string;\n  fontSize: string;\n  paddingTop: string;\n  paddingLeft: string;\n  paddingRight: string;\n}\n\nconst applyStyleToDOMNode = (domNode: HTMLElement, textStyle: ITextElemStyles) => {\n  domNode.className = textStyle.className;\n  domNode.textContent = textStyle.textContent;\n  domNode.style.top = textStyle.top;\n  domNode.style.left = textStyle.left;\n  domNode.style.width = textStyle.width;\n  domNode.style.height = textStyle.height;\n  domNode.style.fontSize = textStyle.fontSize;\n  domNode.style.paddingTop = textStyle.paddingTop;\n  domNode.style.paddingLeft = textStyle.paddingLeft;\n  domNode.style.paddingRight = textStyle.paddingRight;\n};\n\nexport const getTextLabelFragment = (\n    nextCells: Map<string, ICellInternal>,\n    updatePattern: IUpdatePatternItem[],\n    allCurrentlyAttachedDOMNodes: HTMLElement[],\n    pool: Pool,\n  ) => {\n\n  const childrenNodes: HTMLElement[] = [];\n  const updatePatternLength = updatePattern.length;\n  for (let i = 0; i < updatePatternLength; i += 1) {\n    const {key, type} = updatePattern[i];\n    if (type === UpdateType.Enter || type === UpdateType.Update) {\n      const {textLayout, x0, y0, x1, y1} = nextCells.get(key)!;\n      const cellWidth = x1 - x0;\n      const cellHeight = y1 - y0;\n      const generalClassName = 'react-canvas-tree-map-container';\n      const percentageClassName = 'react-canvas-tree-map-container react-canvas-tree-map-percentage';\n      if (textLayout.type === TextLayoutType.ShowBoth) {\n        const {label, share} = textLayout;\n\n        const heightAvailableForLabel = cellHeight * (1 - heightProportionReservedForShare);\n\n        if (label.showText === true) {\n          let paddingTop: string, horizontalPadding: string;\n          if (label.useMargin === true) {\n            paddingTop = `${labelTopMargin * cellHeight}px`;\n            horizontalPadding = `${labelHorizontalMargin * cellWidth}px`;\n          } else {\n            paddingTop = '0';\n            horizontalPadding = '0';\n          }\n\n          const labelElem = pool.dequeue();\n          applyStyleToDOMNode(labelElem, {\n            className: generalClassName,\n            textContent: label.textUnsplit,\n            top: `${y0}px`,\n            left: `${x0}px`,\n            width: `${cellWidth}px`,\n            height: `${heightAvailableForLabel}px`,\n            fontSize: `${label.fontSize}px`,\n            paddingTop,\n            paddingLeft: horizontalPadding,\n            paddingRight: horizontalPadding,\n          });\n          childrenNodes.push(labelElem);\n        }\n\n        if (share.showText === true) {\n          const heightAvailableForPercentage = cellHeight * heightProportionReservedForShare;\n          const top = y0 + heightAvailableForLabel;\n\n          const shareElem = pool.dequeue();\n          applyStyleToDOMNode(shareElem, {\n            className: percentageClassName,\n            textContent: share.text,\n            top: `${top}px`,\n            left: `${x0}px`,\n            width: `${cellWidth}px`,\n            height: `${heightAvailableForPercentage}px`,\n            fontSize: `${share.fontSize}px`,\n            paddingTop: '',\n            paddingLeft: '',\n            paddingRight: '',\n          });\n          childrenNodes.push(shareElem);\n        }\n      } else if (textLayout.type === TextLayoutType.ShowOnlyShare) {\n        const {share} = textLayout;\n        if (share.showText === true) {\n\n          const shareElem = pool.dequeue();\n          applyStyleToDOMNode(shareElem, {\n            className: percentageClassName,\n            textContent: share.text,\n            top: `${y0}px`,\n            left: `${x0}px`,\n            width: `${cellWidth}px`,\n            height: `${cellHeight}px`,\n            fontSize: `${share.fontSize}px`,\n            paddingTop: '',\n            paddingLeft: '',\n            paddingRight: '',\n          });\n          childrenNodes.push(shareElem);\n        }\n      }\n    }\n  }\n  const fragment = document.createDocumentFragment();\n  const rootNode = document.createElement('div');\n  rootNode.className = 'react-canvas-tree-map-masterContainer';\n\n  const childrenNodesLength = childrenNodes.length;\n  for (let j = 0; j < childrenNodesLength; j += 1) {\n    rootNode.appendChild(childrenNodes[j]);\n  }\n\n  fragment.appendChild(rootNode);\n\n  allCurrentlyAttachedDOMNodes = allCurrentlyAttachedDOMNodes.concat(childrenNodes);\n\n  return {\n    fragment, rootNode, allCurrentlyAttachedDOMNodes,\n  };\n};\n","import {\n  useEffect,\n  useRef,\n} from 'react';\n\n// This ref always tracks the value of `value`:\nexport default <T>(value: T) => {\n  const ref = useRef<T>(value);\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref;\n};\n","import {CSSPlugin, TimelineLite, TweenLite} from 'gsap';\nimport createIntervalTree, {\n  IntervalTree,\n} from 'interval-tree-1d';\nimport once from 'lodash/once';\nimport throttle from 'lodash/throttle';\nimport React, {\n  MutableRefObject,\n  useEffect,\n  useRef,\n} from 'react';\nimport styled from 'styled-components/macro';\nimport {\n  sendHeroElementTiming,\n} from './heroElement';\nimport DOMPool from './DOMPool';\nimport {\n  ANGLEInstancedArrays,\n  AttributeBufferRequestType,\n  createPopulatedGLBuffer,\n  EXTDisjointTimerQuery,\n  getProgramInfo,\n  getUpdatePattern,\n  GL_NUM_BYTES_PER_FLOAT,\n  IndexElementType,\n  IProgramInfo,\n  normalizeColorQuadruplet,\n  PersistentFloat32Array,\n  resizeViewport,\n  sendAttributesToGPUWithVAO,\n  sendIndicesToGPUWithVAO,\n  updateGLBuffer,\n  WebGLVersion,\n} from './webglUtils';\nimport {\n  failIfValidOrNonExhaustive,\n  millisecondsPerSeconds,\n  halfStrokeWidth,\n  strokeColor,\n} from './Utils';\nimport {\n  getTextLabelFragment,\n} from './domDependentDrawUtils';\nimport {\n  convertToInternalCells,\n  getIntervalTrees,\n  ICellInternal,\n  NumCellsTier,\n  numFloatsPerCellInstance,\n  rectangleIndices,\n  rectangleIndicesCount,\n  rectangleReferencePositionValues,\n  searchForHits,\n  transitionDuration,\n  writeToCellBuffers,\n} from './domIndependentDrawUtils';\n\nimport {\n  ITreeMapCell,\n} from './otherTypes';\nimport usePropsChangeRateLimiter, {\n  PropsChangeHandlerInput,\n} from './usePropsChangeRateLimiter';\nimport useTrackingRef from './useTrackingRef';\nimport raw from 'raw.macro';\n\n// Need to do this so that `CSSPlugin` is not dropped by the minifier:\nif (!CSSPlugin) {\n  console.error('CSSPlugin failed to load', CSSPlugin);\n}\n\n//#region Styling\nconst Root = styled.div`\n  contain: content;\n  .react-canvas-tree-map-container {\n    position: absolute;\n    color: white;\n    font-weight: 300;\n    box-sizing: border-box;\n  }\n\n  .react-canvas-tree-map-percentage {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n\n  .react-canvas-tree-map-masterContainer {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    opacity: 0;\n    will-change: opacity;\n    -webkit-transition: opacity 175ms ease-out;\n    transition: opacity 175ms ease-out;\n  }\n\n`;\n//#endregion\n\nconst normalizedStrokeColor = normalizeColorQuadruplet(strokeColor);\n\nconst durationInSeconds = transitionDuration / millisecondsPerSeconds;\nconst hoverContinuousHitTestFrameRate = 20;\n\n// This the max number of cells that can possibly appear for all tree maps\n// except the 6-digit product tree map. This is the sum of (the number of\n// 4-digit HS products) + (the number of 4-digit SITC products):\nconst maxNumCellsAtAnyTimeLowTier = 2600;\n// This the max number of cells that can possibly happen when 6 digit is enabled\n// which we call here \"higher tier\".\n// This is the sum of the (number of 6-digit HS products) + max of (number of\n// 4-digit HS products, number of SITC 4-digit products):\nconst maxNumCellsAtAnyTimeHighTier = 8000;\n// for each cell, we draw 2 rectangles: one for stroke and one for fill:\nconst numInstancesPerCell = 2;\n\nenum AnimationStatus {\n  Initial,\n  InProgress,\n  FinishedCompletely,\n}\n\ntype TextContainerTransitionStatus = {\n  isTextContainerChanging: true\n  prevContainer: HTMLElement;\n  prevAttachedDOMNodes: HTMLElement[];\n  nextContainer: HTMLElement;\n  nextAttachedDOMNodes: HTMLElement[];\n  fragment: DocumentFragment;\n} | {\n  isTextContainerChanging: false;\n  currentTextContainer: HTMLElement;\n  currentAttachedDOMNodes: HTMLElement[];\n};\n\ntype Status = {\n  status: AnimationStatus.Initial,\n} | {\n  status: AnimationStatus.InProgress,\n  timeline: gsap.Timeline;\n} | {\n  status: AnimationStatus.FinishedCompletely,\n  // Cell related:\n  currentCells: Map<string, ICellInternal>;\n  currentKeys: string[];\n  cellIndicesCount: number;\n  cellInstancesCount: number;\n\n  // Hit test related\n  xIntervalTree: IntervalTree<string>;\n  yIntervalTree: IntervalTree<string>;\n  // Text related:\n  currentTextContainer: HTMLElement;\n  currentAttachedDOMNodes: HTMLElement[];\n};\n\ninterface IGLInfo {\n  gl: WebGLRenderingContext;\n  vaoExtension: OES_vertex_array_object;\n  timerExtension: EXTDisjointTimerQuery | null;\n  instancedDrawingExtension: ANGLEInstancedArrays;\n  cellsVAO: WebGLVertexArrayObjectOES;\n  cellBuffer: PersistentFloat32Array;\n  cellGLBuffer: WebGLBuffer;\n  rebindGLBuffer: (buffer: PersistentFloat32Array) => void;\n}\n\nconst createCellsBuffer = (numCellsTier: NumCellsTier): PersistentFloat32Array => {\n  let numCells: number;\n  if (numCellsTier === NumCellsTier.Small) {\n    numCells = maxNumCellsAtAnyTimeLowTier;\n  } else if (numCellsTier === NumCellsTier.Large) {\n    numCells = maxNumCellsAtAnyTimeHighTier;\n  } else {\n    failIfValidOrNonExhaustive(numCellsTier, 'Invalid num cells tier' + numCellsTier);\n    // The following lines will never execute:\n    numCells = 0;\n  }\n  return new PersistentFloat32Array(\n    numCells * numInstancesPerCell * numFloatsPerCellInstance,\n  );\n};\n\n// Assume that the cells are not the same if either the identities of the cells are different\n// or the sizes or colors are different:\nconst haveCellsChanged = (prevCells: ITreeMapCell[], nextCells: ITreeMapCell[]): boolean => {\n  const prevCellsLength = prevCells.length;\n  const nextCellsLength = nextCells.length;\n  if (prevCellsLength !== nextCellsLength) {\n    return true;\n  } else {\n    for (let i = 0; i < prevCellsLength; i += 1) {\n      const prevCell = prevCells[i];\n      const nextCell = nextCells[i];\n      if (prevCell.value !== nextCell.value ||\n            prevCell.id !== nextCell.id ||\n            prevCell.color !== nextCell.color) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\nconst setupWebGL = (input: {\n    numCellsTier: NumCellsTier\n    canvasRef: MutableRefObject<HTMLCanvasElement | null>\n    glInfoRef: MutableRefObject<IGLInfo | undefined>\n    cellProgramRef: MutableRefObject<IProgramInfo | undefined>,\n  }) => {\n\n  const {\n    numCellsTier,\n    canvasRef: {current: canvas},\n    glInfoRef, cellProgramRef,\n  } = input;\n  if (canvas !== null) {\n    const gl = canvas.getContext('webgl', {alpha: false});\n    if (gl === null) {\n      console.warn('WebGL not available');\n      glInfoRef.current = undefined;\n    } else {\n      const vaoExtension = gl.getExtension('OES_vertex_array_object');\n      const instancedDrawingExtension = gl.getExtension('ANGLE_instanced_arrays');\n\n      const cellBuffer = createCellsBuffer(numCellsTier);\n\n      let timerExtension: EXTDisjointTimerQuery | null = null;\n      if (process.env.NODE_ENV !== 'production') {\n        timerExtension = gl.getExtension('EXT_disjoint_timer_query');\n      }\n\n      if (vaoExtension === null || instancedDrawingExtension === null) {\n        if (vaoExtension === null) {\n          console.warn('OES_vertex_array_object extension not available.');\n        }\n        if (instancedDrawingExtension === null) {\n          console.warn('ANGLE_instanced_arrays extension not available');\n        }\n        glInfoRef.current = undefined;\n      } else {\n        const cellsVAO = vaoExtension.createVertexArrayOES();\n\n        if (cellsVAO === null) {\n          throw new Error('Cannot create vertex array for cells');\n        }\n\n        const {\n          buffer: cellGLBuffer,\n          rebindBuffer: rebindGLBuffer,\n        } = createPopulatedGLBuffer(gl, cellBuffer);\n\n        cellProgramRef.current = getProgramInfo({\n          version: WebGLVersion.One,\n          gl,\n          vertexShader: raw('./rectangle.vert'),\n          fragmentShader: raw('./rectangle.frag'),\n          attributes: [{\n            name: 'referencePosition',\n            numFloatsPerVertex: 2,\n            buffer: {\n              type: AttributeBufferRequestType.Implicit,\n              totalSizeAsNumOfFloats: rectangleReferencePositionValues.length,\n            },\n            stride: 0,\n            offset: 0,\n            isInstanced: false,\n          }, {\n            name: 'initialTopLeft',\n            numFloatsPerVertex: 2,\n            buffer: {type: AttributeBufferRequestType.Explicit, buffer: cellGLBuffer},\n            stride: numFloatsPerCellInstance * GL_NUM_BYTES_PER_FLOAT,\n            offset: 0,\n            isInstanced: true,\n          }, {\n            name: 'finalTopLeft',\n            numFloatsPerVertex: 2,\n            buffer: {type: AttributeBufferRequestType.Explicit, buffer: cellGLBuffer},\n            stride: numFloatsPerCellInstance * GL_NUM_BYTES_PER_FLOAT,\n            offset: 2 * GL_NUM_BYTES_PER_FLOAT,\n            isInstanced: true,\n          }, {\n            name: 'initialBottomRight',\n            numFloatsPerVertex: 2,\n            buffer: {type: AttributeBufferRequestType.Explicit, buffer: cellGLBuffer},\n            stride: numFloatsPerCellInstance * GL_NUM_BYTES_PER_FLOAT,\n            offset: 4 * GL_NUM_BYTES_PER_FLOAT,\n            isInstanced: true,\n          }, {\n            name: 'finalBottomRight',\n            numFloatsPerVertex: 2,\n            buffer: {type: AttributeBufferRequestType.Explicit, buffer: cellGLBuffer},\n            stride: numFloatsPerCellInstance * GL_NUM_BYTES_PER_FLOAT,\n            offset: 6 * GL_NUM_BYTES_PER_FLOAT,\n            isInstanced: true,\n          }, {\n            name: 'initialColor',\n            numFloatsPerVertex: 4,\n            buffer: {type: AttributeBufferRequestType.Explicit, buffer: cellGLBuffer},\n            stride: numFloatsPerCellInstance * GL_NUM_BYTES_PER_FLOAT,\n            offset: 8 * GL_NUM_BYTES_PER_FLOAT,\n            isInstanced: true,\n          }, {\n            name: 'finalColor',\n            numFloatsPerVertex: 4,\n            buffer: {type: AttributeBufferRequestType.Explicit, buffer: cellGLBuffer},\n            stride: numFloatsPerCellInstance * GL_NUM_BYTES_PER_FLOAT,\n            offset: 12 * GL_NUM_BYTES_PER_FLOAT,\n            isInstanced: true,\n          }, {\n            name: 'halfStrokeWidth',\n            numFloatsPerVertex: 1,\n            buffer: {type: AttributeBufferRequestType.Explicit, buffer: cellGLBuffer},\n            stride: numFloatsPerCellInstance * GL_NUM_BYTES_PER_FLOAT,\n            offset: 16 * GL_NUM_BYTES_PER_FLOAT,\n            isInstanced: true,\n          }],\n          uniforms: ['canvasSize', 'tweenProgress'],\n          indexBuffer: {elementType: IndexElementType.Int16, totalSizeAsNumOfInts: rectangleIndicesCount},\n          vaoObject: cellsVAO,\n          vaoExtension,\n          instancedDrawingExtension,\n        });\n\n        glInfoRef.current = {\n          gl, vaoExtension, timerExtension, instancedDrawingExtension, cellsVAO,\n          cellBuffer, cellGLBuffer, rebindGLBuffer,\n        };\n      }\n    }\n  }\n};\n\nconst setWidthHeightInCSSPixels = (input: {\n    canvasRef: MutableRefObject<HTMLCanvasElement | null>,\n    widthInCSSPixelsRef: MutableRefObject<number | undefined>,\n    heightInCSSPixelsRef: MutableRefObject<number | undefined>,\n  }) => {\n\n  const {\n    canvasRef: {current: canvas},\n    widthInCSSPixelsRef, heightInCSSPixelsRef,\n  } = input;\n\n  if (canvas !== null) {\n    const {width, height} = canvas.getBoundingClientRect();\n    widthInCSSPixelsRef.current = width;\n    heightInCSSPixelsRef.current = height;\n  }\n};\n\nconst upgradeToLargeBuffer = (glInfo: IGLInfo) => {\n  const newCellBuffer = createCellsBuffer(NumCellsTier.Large);\n  newCellBuffer.copyFrom(glInfo.cellBuffer);\n  glInfo.cellBuffer = newCellBuffer;\n  glInfo.rebindGLBuffer(newCellBuffer);\n};\n\ntype IMonitoredProps = Pick<\n  IProps,\n  'cells' | 'highlighted' | 'numCellsTier' | 'chartContainerHeight' | 'chartContainerWidth'\n>;\n\ninterface IPropsChangeHandlerExtraInputs {\n  rootElRef: MutableRefObject<HTMLDivElement | null>;\n  glInfoRef: MutableRefObject<IGLInfo | undefined>;\n  cellProgramRef: MutableRefObject<IProgramInfo | undefined>;\n  statusRef: MutableRefObject<Status>;\n  domPoolRef: MutableRefObject<DOMPool>;\n  upgradeToLargeBufferRef: MutableRefObject<typeof upgradeToLargeBuffer>;\n  sendHeroElementTimingOnceRef: MutableRefObject<typeof sendHeroElementTiming>;\n}\n\nconst performPropsChange =\n  (input: PropsChangeHandlerInput<IPropsChangeHandlerExtraInputs, IMonitoredProps>) => {\n\n  const {\n    nextValue,\n    extraInputs: {\n      rootElRef: {current: rootEl},\n      glInfoRef: {current: glInfo},\n      cellProgramRef: {current: cellProgram},\n      statusRef: {current: prevStatus}, statusRef,\n      domPoolRef,\n      upgradeToLargeBufferRef: {current: upgradeBuffer},\n      sendHeroElementTimingOnceRef: {current: sendHeroElementTimingOnce},\n    },\n    done,\n  } = input;\n\n  const prevValue = (input.prevValue === undefined) ? nextValue : input.prevValue;\n  const hasChartSizeChanged =\n    (nextValue.chartContainerHeight !== prevValue.chartContainerHeight ||\n    nextValue.chartContainerWidth !== prevValue.chartContainerWidth) &&\n    (nextValue.chartContainerHeight !== undefined && nextValue.chartContainerWidth !== undefined);\n\n  if (hasChartSizeChanged && glInfo !== undefined) {\n    const {gl} = glInfo;\n    resizeViewport(gl, true);\n  }\n\n  const {\n    chartContainerHeight, chartContainerWidth,\n  } = nextValue;\n\n  if (glInfo !== undefined && cellProgram !== undefined && rootEl !== null) {\n\n    if (hasChartSizeChanged === true ||\n        // This is true on the very first render:\n        (input.prevValue === undefined) ||\n        // This is true when the data changes on subsequent renders:\n        (input.prevValue !== undefined &&\n          (haveCellsChanged(prevValue.cells, nextValue.cells)) ||\n            prevValue.highlighted !== nextValue.highlighted)\n      ) {\n\n      if (nextValue.numCellsTier !== prevValue.numCellsTier &&\n            prevValue.numCellsTier === NumCellsTier.Small &&\n            nextValue.numCellsTier === NumCellsTier.Large) {\n\n        upgradeBuffer(glInfo);\n      }\n\n      const {\n        gl, vaoExtension,\n        instancedDrawingExtension,\n        cellsVAO,\n        cellBuffer, cellGLBuffer,\n      } = glInfo;\n      if (prevStatus.status === AnimationStatus.FinishedCompletely ||\n          prevStatus.status === AnimationStatus.Initial) {\n\n        let prevCells: Map<string, ICellInternal>, prevKeys: string[];\n        let prevTextContainer: HTMLElement, prevAttachedDOMNodes: HTMLElement[];\n        if (prevStatus.status === AnimationStatus.FinishedCompletely) {\n          prevCells = prevStatus.currentCells;\n          prevKeys = prevStatus.currentKeys;\n          prevTextContainer = prevStatus.currentTextContainer;\n          prevAttachedDOMNodes = prevStatus.currentAttachedDOMNodes;\n        } else if (prevStatus.status === AnimationStatus.Initial) {\n          prevCells = new Map();\n          prevKeys = [];\n          prevTextContainer = document.createElement('div');\n          prevAttachedDOMNodes = [];\n\n          // Bind non-instanced attributes and indices for the 2 vertex shaders.\n          // This only needs to happen once because they never change:\n          vaoExtension.bindVertexArrayOES(cellsVAO);\n          sendAttributesToGPUWithVAO({\n            gl, programInfo: cellProgram,\n            attributeName: 'referencePosition',\n            data: new Float32Array(rectangleReferencePositionValues),\n          });\n          sendIndicesToGPUWithVAO({\n            gl, programInfo: cellProgram, data: new Uint16Array(rectangleIndices),\n          });\n\n          vaoExtension.bindVertexArrayOES(null);\n\n          gl.disable(gl.DEPTH_TEST);\n          gl.enable(gl.BLEND);\n          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n          gl.clearColor(1, 1, 1, 1);\n        } else {\n          failIfValidOrNonExhaustive(prevStatus, 'Invalid status type');\n          // These lines will never be executed:\n          prevCells = new Map();\n          prevKeys = [];\n          prevTextContainer = undefined as any;\n          prevAttachedDOMNodes = [];\n        }\n\n        const {cells, highlighted} = nextValue;\n        const {nextKeys, nextCells} = convertToInternalCells(cells, highlighted);\n        const updatePattern = getUpdatePattern(prevKeys, nextKeys);\n        const cellsInfo = writeToCellBuffers(\n          prevCells, nextCells, updatePattern, halfStrokeWidth, normalizedStrokeColor, cellBuffer,\n        );\n        // Update vertex data for cells:\n        updateGLBuffer({gl, buffer: cellGLBuffer, data: cellBuffer.getMeaningfulData()});\n\n        // `false` means the next update actually has no data to show so we should skip the animation:\n        const doesNextUpdateHaveData = nextValue.cells.length > 0;\n\n        let nextXIntervalTree: IntervalTree<string>, nextYIntervalTree: IntervalTree<string>;\n        if ((doesNextUpdateHaveData && nextValue.cells !== prevValue.cells) ||\n            prevStatus.status === AnimationStatus.Initial) {\n\n          const intervalTrees = getIntervalTrees(nextKeys, nextCells, createIntervalTree);\n          nextXIntervalTree = intervalTrees.xIntervalTree;\n          nextYIntervalTree = intervalTrees.yIntervalTree;\n        } else {\n          nextXIntervalTree = prevStatus.xIntervalTree;\n          nextYIntervalTree = prevStatus.yIntervalTree;\n        }\n\n        const tweenTarget = {tweenProgress: 0};\n\n        const timeline = new TimelineLite({paused: true});\n        const timelineStartTime = 0;\n\n        let textContainerStatus: TextContainerTransitionStatus;\n        if (nextValue.cells !== prevValue.cells ||\n            prevStatus.status === AnimationStatus.Initial) {\n          const {\n            rootNode, fragment, allCurrentlyAttachedDOMNodes,\n          } = getTextLabelFragment(nextCells, updatePattern, prevAttachedDOMNodes, domPoolRef.current);\n          textContainerStatus = {\n            isTextContainerChanging: true,\n            prevAttachedDOMNodes,\n            prevContainer: prevTextContainer,\n            nextAttachedDOMNodes: allCurrentlyAttachedDOMNodes,\n            nextContainer: rootNode,\n            fragment,\n          };\n        } else {\n          textContainerStatus = {\n            isTextContainerChanging: false,\n            currentAttachedDOMNodes: prevAttachedDOMNodes,\n            currentTextContainer: prevTextContainer,\n          };\n        }\n        if (textContainerStatus.isTextContainerChanging === true) {\n          timeline.set(textContainerStatus.nextContainer, {css: {opacity: 1}}, durationInSeconds / 2);\n          timeline.set(textContainerStatus.prevContainer, {css: {opacity: 0}}, timelineStartTime);\n        }\n\n        const setupVisibleDraw = (inputWidth: number, inputHeight: number) => {\n          gl.useProgram(cellProgram.program);\n          gl.uniform2f(cellProgram.uniforms.canvasSize, inputWidth, inputHeight);\n\n          vaoExtension.bindVertexArrayOES(cellsVAO);\n        };\n\n        const onAnimationUpdate = () => {\n          const {tweenProgress} = tweenTarget;\n\n          gl.uniform1f(cellProgram.uniforms.tweenProgress, tweenProgress);\n          // tslint:disable-next-line:no-bitwise\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n          instancedDrawingExtension.drawElementsInstancedANGLE(\n            gl.TRIANGLES, rectangleIndicesCount, cellProgram.indexBuffer.elementType, 0, cellsInfo.instancesCount,\n          );\n        };\n\n        const reportHeroElementTimingIfNeeded = () => {\n          if (chartContainerHeight !== undefined &&\n                chartContainerWidth !== undefined && cells.length > 0) {\n            sendHeroElementTimingOnce('tree map');\n          }\n        };\n\n        const onAnimationComplete = () => {\n          vaoExtension.bindVertexArrayOES(null);\n\n          const endProspChangeTransition = () => {\n            reportHeroElementTimingIfNeeded();\n\n            statusRef.current = {\n              status: AnimationStatus.FinishedCompletely,\n              // cells related:\n              currentCells: nextCells,\n              currentKeys: nextKeys,\n              cellIndicesCount: rectangleIndicesCount,\n              cellInstancesCount: cellsInfo.instancesCount,\n              // Text related:\n              currentTextContainer: newTextContainer,\n              currentAttachedDOMNodes: newAttachedDOMNOdes,\n              // Hit test related:\n              xIntervalTree: nextXIntervalTree,\n              yIntervalTree: nextYIntervalTree,\n            };\n\n            done();\n          };\n          let newAttachedDOMNOdes: HTMLElement[], newTextContainer: HTMLElement;\n          if (textContainerStatus.isTextContainerChanging === true) {\n            newAttachedDOMNOdes = textContainerStatus.nextAttachedDOMNodes;\n            newTextContainer = textContainerStatus.nextContainer;\n            const domNodesToRemove = textContainerStatus.prevAttachedDOMNodes;\n            const textContainerToRemove = textContainerStatus.prevContainer;\n            requestAnimationFrame(() => {\n              const domPool = domPoolRef.current;\n              const prevAttachedDOMNodesLength = domNodesToRemove.length;\n              textContainerToRemove.remove();\n              for (let j = 0; j < prevAttachedDOMNodesLength; j += 1) {\n                domPool.enqueue(domNodesToRemove[j]);\n              }\n              endProspChangeTransition();\n            });\n\n          } else {\n            newAttachedDOMNOdes = textContainerStatus.currentAttachedDOMNodes;\n            newTextContainer = textContainerStatus.currentTextContainer;\n            endProspChangeTransition();\n          }\n        };\n        const animationTween = TweenLite.to(tweenTarget, durationInSeconds, {\n          tweenProgress: 1,\n          ease: 'Cubic.easeOut',\n          onUpdate: onAnimationUpdate,\n          onComplete: onAnimationComplete,\n        });\n        timeline.add(animationTween, timelineStartTime);\n\n        statusRef.current = {\n          status: AnimationStatus.InProgress, timeline,\n        };\n        setupVisibleDraw(nextValue.chartContainerWidth, nextValue.chartContainerHeight);\n        if (doesNextUpdateHaveData === true) {\n          requestAnimationFrame(() => {\n            if (textContainerStatus.isTextContainerChanging === true) {\n              rootEl.appendChild(textContainerStatus.fragment);\n            }\n\n            // If there's nothing to render in `nextProps` (usually due to error\n            // or all categories deselected), we want to just clear the screen\n            // instead of going through a draw operation:\n            requestAnimationFrame(() => {\n              timeline.play();\n            });\n          });\n\n        } else {\n          gl.clearColor(1, 1, 1, 1);\n          // tslint:disable-next-line:no-bitwise\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n          onAnimationComplete();\n        }\n\n      }\n    } else {\n      done();\n    }\n  } else {\n    done();\n  }\n};\nconst performHitTest = (input: {\n    status: Status,\n    mouseClientX: number | undefined,\n    mouseClientY: number | undefined,\n    canvas: HTMLCanvasElement | null,\n    chartWidth: number | undefined,\n    chartHeight: number | undefined,\n  }) => {\n\n  const {\n    status,\n    mouseClientX, mouseClientY,\n    canvas, chartWidth, chartHeight,\n  } = input;\n  if (mouseClientX !== undefined && mouseClientY !== undefined && canvas !== null &&\n      chartWidth !== undefined && chartHeight !== undefined) {\n    if (status.status === AnimationStatus.FinishedCompletely) {\n      const {top, left} = canvas.getBoundingClientRect();\n      const {xIntervalTree, yIntervalTree} = status;\n      const relativeX = mouseClientX - left;\n      const relativeY = mouseClientY - top;\n\n      const searchResult = searchForHits(\n        xIntervalTree, yIntervalTree, chartWidth, chartHeight, relativeX, relativeY,\n      );\n      return searchResult;\n    } else {\n      return undefined;\n    }\n  } else {\n    return undefined;\n  }\n\n};\n\nconst getUnthrottledHoverHandler = (input: {\n    statusRef: MutableRefObject<Status>,\n    canvasRef: MutableRefObject<HTMLCanvasElement | null>,\n    isTransitionInProgress: () => boolean,\n    onMouseOverCellRef: MutableRefObject<IProps['onMouseOverCell']>,\n    onMouseLeaveChartRef: MutableRefObject<IProps['onMouseLeaveChart']>,\n    chartWidthRef: MutableRefObject<IProps['chartContainerWidth']>\n    chartHeightRef: MutableRefObject<IProps['chartContainerHeight']>\n\n    // Note: need to update these refs every time before invoking the throttled\n    // version of `performHover`:\n    mouseClientXRef: MutableRefObject<number | undefined>,\n    mouseClientYRef: MutableRefObject<number | undefined>,\n  }) => {\n\n  const {\n    onMouseLeaveChartRef, onMouseOverCellRef, canvasRef,\n    mouseClientXRef, mouseClientYRef,\n    chartWidthRef, chartHeightRef,\n    statusRef, isTransitionInProgress,\n  } = input;\n\n  let hoveredNode: string | undefined;\n\n  return () => {\n    const {current: status} = statusRef;\n    if (isTransitionInProgress() === false && status.status === AnimationStatus.FinishedCompletely) {\n      const prevHoveredNode = hoveredNode;\n      const {current: chartWidth} = chartWidthRef;\n      const {current: chartHeight} = chartHeightRef;\n      if (chartWidth !== undefined && chartHeight !== undefined) {\n        const nextHoveredNode = performHitTest({\n          status,\n          mouseClientX: mouseClientXRef.current,\n          mouseClientY: mouseClientYRef.current,\n          canvas: canvasRef.current,\n          chartWidth,\n          chartHeight,\n        });\n        hoveredNode = nextHoveredNode;\n        const {current: onMouseOverCell} = onMouseOverCellRef;\n        const {current: onMouseLeaveChart} = onMouseLeaveChartRef;\n        if (nextHoveredNode !== prevHoveredNode) {\n          if (prevHoveredNode === undefined && nextHoveredNode !== undefined) {\n            onMouseOverCell(nextHoveredNode);\n          } else if (prevHoveredNode !== undefined && nextHoveredNode === undefined) {\n            onMouseLeaveChart();\n          } else if (prevHoveredNode !== undefined && nextHoveredNode !== undefined) {\n            onMouseOverCell(nextHoveredNode);\n          }\n        }\n      }\n    }\n  };\n\n};\n\nexport interface IProps {\n  highlighted: string | undefined;\n  cells: ITreeMapCell[];\n  comparisonCells?: ITreeMapCell[];\n\n  numCellsTier: NumCellsTier;\n\n  chartContainerWidth: number ;\n  chartContainerHeight: number;\n\n  onCellClick: (id: string) => void;\n  onMouseOverCell: (id: string) => void;\n  onMouseLeaveChart: () => void;\n}\n\nexport default (props: IProps) => {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  const statusRef = useRef<Status>({status: AnimationStatus.Initial});\n  const glInfoRef = useRef<IGLInfo | undefined>(undefined);\n  const cellProgramRef = useRef<IProgramInfo | undefined>(undefined);\n  const domPoolRef = useRef<DOMPool>(new DOMPool(1000, 'div'));\n  const rootElRef = useRef<HTMLDivElement | null>(null);\n\n  const upgradeToLargeBufferRef = useRef(once(upgradeToLargeBuffer));\n  const sendHeroElementTimingOnceRef = useRef(once(sendHeroElementTiming));\n\n  const {\n    numCellsTier, cells, highlighted,\n    chartContainerHeight, chartContainerWidth,\n  } = props;\n\n  const chartWidthRef = useTrackingRef(chartContainerWidth);\n  const chartHeightRef = useTrackingRef(chartContainerHeight);\n  const onMouseOverCellRef = useTrackingRef(props.onMouseOverCell);\n  const onMouseLeaveChartRef = useTrackingRef(props.onMouseLeaveChart);\n\n  useEffect(() => {\n    setupWebGL({numCellsTier, canvasRef, glInfoRef, cellProgramRef});\n    const {current: glInfo} = glInfoRef;\n    if (props.chartContainerWidth !== undefined &&\n        props.chartContainerHeight !== undefined &&\n        glInfo !== undefined) {\n      const {gl} = glInfo;\n      setWidthHeightInCSSPixels({\n        canvasRef,\n        widthInCSSPixelsRef: chartWidthRef,\n        heightInCSSPixelsRef: chartHeightRef,\n      });\n      resizeViewport(gl, true);\n    }\n\n    return () => {\n      const {current: innerGLInfo} = glInfoRef;\n      const {current: status} = statusRef;\n      if (innerGLInfo !== undefined) {\n        if (status.status === AnimationStatus.InProgress) {\n          const {timeline} = status;\n          (timeline as any).stop();\n        }\n        const {gl, cellGLBuffer} = innerGLInfo;\n        innerGLInfo.cellBuffer = null as any;\n        gl.deleteBuffer(cellGLBuffer);\n      }\n    };\n  }, []);\n\n  const {\n    isTransitionInProgress,\n  } = usePropsChangeRateLimiter<IPropsChangeHandlerExtraInputs, IMonitoredProps>({\n    value: {\n      cells, highlighted, numCellsTier,\n      chartContainerHeight, chartContainerWidth,\n    },\n    getExtraInputToPropsChangeHandler: () => ({\n      glInfoRef, cellProgramRef,\n      widthInCSSPixelsRef: chartWidthRef,\n      heightInCSSPixelsRef: chartHeightRef,\n      statusRef, domPoolRef, upgradeToLargeBufferRef, sendHeroElementTimingOnceRef,\n      rootElRef,\n    }),\n    performPropsChange,\n  });\n\n  const mouseClientXRef = useRef<number | undefined>(undefined);\n  const mouseClientYRef = useRef<number | undefined>(undefined);\n\n  const unthrottledHoverHandler = getUnthrottledHoverHandler({\n    statusRef, canvasRef, isTransitionInProgress,\n    onMouseOverCellRef, onMouseLeaveChartRef, chartWidthRef, chartHeightRef,\n    mouseClientXRef, mouseClientYRef,\n  });\n\n  // We perform hover hit test at 20fps:\n  const throttledPerformHoverRef = useRef(\n    throttle(unthrottledHoverHandler, millisecondsPerSeconds / hoverContinuousHitTestFrameRate),\n  );\n\n  const onMouseLeave = () => {\n    const {current: throttledHover} = throttledPerformHoverRef;\n    throttledHover.cancel();\n    props.onMouseLeaveChart();\n  };\n\n  const onMouseMove = ({clientX, clientY}: React.MouseEvent<any>) => {\n    mouseClientXRef.current = clientX;\n    mouseClientYRef.current = clientY;\n    const {current: throttledPerformHover} = throttledPerformHoverRef;\n    if (isTransitionInProgress() === false) {\n      throttledPerformHover();\n    }\n  };\n\n  const onClick = () => {\n    if (isTransitionInProgress() === false) {\n      const {current: status} = statusRef;\n      if (status.status === AnimationStatus.FinishedCompletely) {\n        const result = performHitTest({\n          status,\n          mouseClientX: mouseClientXRef.current,\n          mouseClientY: mouseClientYRef.current,\n          canvas: canvasRef.current,\n          chartWidth: chartContainerWidth,\n          chartHeight: chartContainerHeight,\n        });\n        if (result !== undefined) {\n          props.onCellClick(result);\n        }\n      }\n    }\n\n  };\n\n  return (\n    <Root ref={rootElRef}\n      onMouseLeave={onMouseLeave}\n      onMouseMove={onMouseMove}\n      onClick={onClick}\n      style={{width: props.chartContainerWidth, height: chartContainerHeight}}\n    >\n      <canvas\n        ref={canvasRef}\n        style={{width: props.chartContainerWidth, height: chartContainerHeight}}\n      />\n    </Root>\n  );\n\n};\n","import {\n  useEffect,\n  useRef,\n} from 'react';\n\nexport interface PropsChangeHandlerInput<PropsChangeHandlerExtraInputs, Props> {\n  prevValue: Props | undefined;\n  nextValue: Props;\n  extraInputs: PropsChangeHandlerExtraInputs;\n  done: () => void;\n}\n\ninterface IInput<PropsChangeHandlerExtraInputs, Props> {\n  getExtraInputToPropsChangeHandler: () => PropsChangeHandlerExtraInputs;\n  value: Props;\n  performPropsChange: (input: PropsChangeHandlerInput<PropsChangeHandlerExtraInputs, Props>) => void;\n}\n\nexport default <PropsChangeHandlerExtraInputs, Props>(\n    input: IInput<PropsChangeHandlerExtraInputs, Props>) => {\n\n  const {\n    value, getExtraInputToPropsChangeHandler,\n    performPropsChange,\n  } = input;\n  const nextValueRef = useRef<Props | undefined>(undefined);\n  const prevValueRef = useRef<Props | undefined>(undefined);\n  const isTransitionInProgressRef = useRef<boolean>(false);\n\n  const onPropsChangeComplete = () => {\n    isTransitionInProgressRef.current = false;\n    performNextValueChange();\n  };\n\n  const performNextValueChange = () => {\n    const {current: nextValue} = nextValueRef;\n    const {current: prevValue} = prevValueRef;\n    if (nextValue !== undefined && isTransitionInProgressRef.current === false) {\n      prevValueRef.current = nextValue;\n      nextValueRef.current = undefined;\n      if (prevValue === undefined) {\n        isTransitionInProgressRef.current = true;\n        const extraInputs = getExtraInputToPropsChangeHandler();\n        performPropsChange({\n          prevValue, nextValue,\n          extraInputs, done: onPropsChangeComplete,\n        });\n      } else {\n        if (nextValue !== prevValue) {\n          isTransitionInProgressRef.current = true;\n          const extraInputs = getExtraInputToPropsChangeHandler();\n          performPropsChange({\n            prevValue, nextValue,\n            extraInputs, done: onPropsChangeComplete,\n          });\n        }\n      }\n    }\n  };\n\n  useEffect(() => {\n    nextValueRef.current = value;\n    performNextValueChange();\n  }, [value]);\n\n  return {\n    isTransitionInProgress: () => isTransitionInProgressRef.current,\n  };\n};\n","import initial from 'lodash/initial';\nimport last from 'lodash/last';\nimport sum from 'lodash/sum';\nimport {\n  ellipsisCharacter as ellipsis,\n} from './Utils';\n\nconst wordSeparator = ' ';\n\ninterface IFontMeasurement {\n  maxCharacterWidth: number;\n  maxCharacterHeight: number;\n}\n\ninterface IRectangle {\n  width: number;\n  height: number;\n}\n\ninterface IWord {\n  text: string;\n  width: number;\n}\n\ntype ILayoutAttemptResult = {\n  success: boolean,\n  // Each element in the array represents a row. Each row is in turn an array of\n  // words.\n  lines: ILine[];\n};\n\ninterface ILine {\n  text: string;\n  words: IWord[];\n}\n\nconst attemptFitTextInsideRectangle = (input: {\n    text: string,\n    referenceMeasurement: IFontMeasurement,\n    referenceFontSize: number,\n    rectangle: IRectangle,\n    fontSizeToTry: number;\n  }): ILayoutAttemptResult => {\n\n  const {\n    text, referenceMeasurement, referenceFontSize, rectangle, fontSizeToTry,\n  } = input;\n\n  // Scale up/down the measured width/height according to the `fontSizeToTry`:\n  const maxCharacterHeight = fontSizeToTry / referenceFontSize * referenceMeasurement.maxCharacterHeight;\n  const maxCharacterWidth = fontSizeToTry / referenceFontSize * referenceMeasurement.maxCharacterWidth;\n\n  const {width, height} = rectangle;\n  const maxLineNumber = Math.floor(height / maxCharacterHeight);\n  const words: IWord[] = text.split(wordSeparator).map(word => ({\n    text: word,\n    width: word.length * maxCharacterWidth,\n  }));\n  const [firstWord, ...remainingWords] = words;\n\n  const isEveryWordShorterThanRectangle = words.every(word => word.width < width);\n\n  // If at least one word is longer than the rectangle's width or the\n  // rectangle's height is shorter than the height of a single lint of text, the\n  // text is too big to fit.\n  if (!isEveryWordShorterThanRectangle || maxCharacterHeight > height) {\n\n    return {\n      success: false,\n      lines: [],\n    };\n\n  } else {\n    const fitResult: IWord[][] = [ [firstWord] ];\n\n    let lineNumber = 1;\n    // Because (the area of the first word) < (total rectangle area), we know\n    // the first word will fit:\n    let lineLengthLeft = width - firstWord.width;\n\n    // Keep doing this as long as there are still words remaining and we haven't\n    // run out of space in the rectangle:\n    while (remainingWords.length) {\n\n      const wordToFit = remainingWords.shift()!;\n      if (wordToFit.width < lineLengthLeft) {\n        // If there's enough space left on the current line for the word then add\n        // it to the line:{\n        const [lastFitResult] = fitResult.slice(-1);\n        lastFitResult.push(wordToFit);\n        // Need to also subtract the width by the amount taken by the space\n        // separating the words:\n        lineLengthLeft = lineLengthLeft - wordToFit.width - maxCharacterWidth;\n      } else {\n       // Else, start a new line if possible\n        lineNumber = lineNumber + 1;\n        fitResult.push([]);\n        // Return the attempted word to the pool of remaining words to fit:\n        remainingWords.unshift(wordToFit!);\n        lineLengthLeft = width;\n      }\n    }\n\n    const lines: ILine[] = fitResult.map(wordsInLine => {\n      const wordsBeforeLast = initial(wordsInLine);\n      const lastWord = last(wordsInLine)!;\n      const newWordsBeforeLast = wordsBeforeLast.map(word => ({\n        text: word.text + wordSeparator,\n        width: word.width + maxCharacterWidth,\n      }));\n      const newWords = [...newWordsBeforeLast, lastWord];\n      const newText = newWords.map(word => word.text).join('');\n      return {\n        text: newText,\n        words: newWords,\n      };\n    });\n    const isSuccessful = (lines.length <= maxLineNumber);\n\n    return {\n      success: isSuccessful,\n      lines,\n    };\n  }\n};\n\ninterface IFontSizeDetermination {\n  fontSize: number;\n  lines: ILine[];\n}\n\nexport const determineFontSizeToFit = (\n  input: {\n    text: string,\n    referenceMeasurement: IFontMeasurement,\n    referenceFontSize: number,\n    rectangle: IRectangle,\n  }): IFontSizeDetermination => {\n\n  const {text, referenceFontSize, referenceMeasurement, rectangle} = input;\n  const {maxCharacterHeight, maxCharacterWidth} = referenceMeasurement;\n  const {width, height} = rectangle;\n  const totalTextArea = text.length * maxCharacterHeight * maxCharacterWidth;\n  const totalRectangleArea = width * height;\n\n  // This is the font size for which the total text area = rectangle's area.\n  // This is the max font size the text can possibly have:\n  const maxFontSize = (Math.sqrt((totalRectangleArea / totalTextArea) * Math.pow(16, 2)));\n\n  // Use bisection to figure out the optimize font size. Stop when the two bounds\n  // converge to within 0.01:\n  let upperBound = maxFontSize;\n  let lowerBound = 0;\n  let sizeToTry: number | undefined;\n  let layoutResult: ILine[] | undefined;\n  while (Math.abs(upperBound - lowerBound) > 0.01) {\n    sizeToTry = (upperBound + lowerBound) / 2;\n    // TODO: memoize this function call:\n    const layoutAttempt = attemptFitTextInsideRectangle({\n      text, referenceMeasurement, referenceFontSize, rectangle,\n      fontSizeToTry: sizeToTry,\n    });\n    let newUpperBound: number, newLowerBound: number;\n    if (layoutAttempt.success) {\n      layoutResult = layoutAttempt.lines;\n      newUpperBound = upperBound;\n      newLowerBound = sizeToTry;\n    } else {\n      newUpperBound = sizeToTry;\n      newLowerBound = lowerBound;\n    }\n    upperBound = newUpperBound;\n    lowerBound = newLowerBound;\n  }\n\n  return {\n    fontSize: sizeToTry!,\n    lines: layoutResult!,\n  };\n};\n\nexport const truncateTextInRectangle = (input: {\n    text: string,\n    referenceMeasurement: IFontMeasurement,\n    referenceFontSize: number,\n    rectangle: IRectangle,\n    fontSizeToTry: number;\n  }): ILine[] => {\n\n  const {\n    fontSizeToTry, referenceFontSize,\n    referenceMeasurement,\n    rectangle: {height, width},\n  } = input;\n  const maxCharacterHeight = fontSizeToTry / referenceFontSize * referenceMeasurement.maxCharacterHeight;\n  const maxCharacterWidth = fontSizeToTry / referenceFontSize * referenceMeasurement.maxCharacterWidth;\n\n  const isEveryWordShorterThanRectangle = input.text.split(wordSeparator).every(\n    word => word.length * maxCharacterWidth < width,\n  );\n\n  let result: ILine[];\n  if (isEveryWordShorterThanRectangle === false) {\n    // If at least one word is longer the rectangle, the layout algorithm won't be able to fit the text in.\n    // In that case, just trim the first word\n    const firstWord = input.text.split(wordSeparator)[0];\n    const maxCharacterCountToFitWidth = Math.floor(width / maxCharacterWidth);\n    const trimmedFirstWord = `${firstWord.slice(0, maxCharacterCountToFitWidth)}${ellipsis}`;\n    result = [{\n      text: trimmedFirstWord,\n      words: [{\n        text: trimmedFirstWord,\n        width: maxCharacterCountToFitWidth * maxCharacterWidth,\n      }],\n    }];\n\n  } else {\n    const maxNumOfLines = Math.floor(height / maxCharacterHeight);\n    const {lines} = attemptFitTextInsideRectangle(input);\n\n    if (lines.length > 0) {\n      // Only keep the lines that fit vertically within the rectangle:\n      const retainedLines = lines.slice(0, maxNumOfLines);\n      const linesBeforeLast = initial(retainedLines);\n      const lastLine = last(retainedLines)!;\n\n      // Add ellipsis to the end of the last line:\n      const totalLengthOfLastLine = sum(lastLine.words.map(word => word.width));\n      let newLastLine: ILine;\n      if (totalLengthOfLastLine < width - maxCharacterWidth) {\n        // If there's enough leftover space on the last line for the ellipsis, simply append\n        // the ellipsis after the last character:\n        const {words} = lastLine;\n        const wordsOtherThanLast = initial(words);\n        const lastWord = last(words)!;\n        const newLastWord = {\n          text: lastWord.text + ellipsis,\n          width: lastWord.width + maxCharacterWidth,\n        };\n        newLastLine = {\n          text: lastLine.text + ellipsis,\n          words: [...wordsOtherThanLast, newLastWord],\n        };\n      } else {\n        // Otherwise, relace the last character with the ellipsis:\n        const {words} = lastLine;\n        const wordsBeforeLast = initial(words);\n        const lastWord = last(words)!;\n        const newLastWord = {\n          text: lastWord.text.replace(/.$/, ellipsis),\n          width: lastWord.width,\n        };\n        newLastLine = {\n          text: lastLine.text.replace(/.$/, ellipsis),\n          words: [...wordsBeforeLast, newLastWord],\n        };\n      }\n\n      result = [...linesBeforeLast, newLastLine];\n    } else {\n      result = [];\n    }\n\n  }\n\n  return result;\n};\n","import {\n  LabelLayout,\n  ShareLayout,\n  TextLayout,\n  TextLayoutType,\n} from './otherTypes';\nimport {\n  heightProportionReservedForShare,\n  labelHorizontalMargin,\n  labelTopMargin,\n  minNodeNameFontSize,\n} from './transformUtils';\nimport {\n  determineFontSizeToFit,\n  truncateTextInRectangle,\n} from './fitTextInRectangle';\n\ninterface Rect {\n  x0: number;\n  y0: number;\n  x1: number;\n  y1: number;\n}\n\nexport type WithTextLayout<T> = T & {\n  textLayout: TextLayout;\n};\n\nconst addTextLayout = <T extends Rect>(input: {\n    datum: T,\n    referenceFontSize: number,\n    measuredCharacterHeight: number,\n    measuredCharacterWidth: number,\n    maxCharacterHeightAtMinFontSize: number,\n    cellLabel: string,\n    cellValue: string,\n  }) => {\n  const {\n    datum, referenceFontSize, measuredCharacterHeight, measuredCharacterWidth,\n    maxCharacterHeightAtMinFontSize, cellLabel, cellValue,\n  } = input;\n  const {x0, y0, x1, y1} = datum;\n  const fullWidth = x1 - x0;\n  const fullHeight = y1 - y0;\n\n  const widthMinusMargin = fullWidth * (1 - 2 * labelHorizontalMargin);\n  const fullAvailableHeightForLabel = fullHeight * (1 - heightProportionReservedForShare);\n  const heightMinusMargin = fullAvailableHeightForLabel * (1 - labelTopMargin);\n\n  // First try to fit text with margin:\n  const labelLayoutWithMargin = determineFontSizeToFit({\n    text: cellLabel,\n    referenceFontSize,\n    referenceMeasurement: {\n      maxCharacterHeight: measuredCharacterHeight,\n      maxCharacterWidth: measuredCharacterWidth,\n    },\n    rectangle: {width: widthMinusMargin, height: heightMinusMargin},\n  });\n\n  //#region Label layout\n  let labelLayout: LabelLayout;\n  if (labelLayoutWithMargin.fontSize > minNodeNameFontSize) {\n    const textSplitIntoLines = labelLayoutWithMargin.lines.map(line => line.text);\n    labelLayout = {\n      showText: true,\n      fontSize: labelLayoutWithMargin.fontSize,\n      textSplitIntoLines,\n      textUnsplit: textSplitIntoLines.join(' '),\n      useMargin: true,\n    };\n  } else {\n    // If text doesn't fit when margin is present, try again without margin:\n    const layoutResultWithoutMargin = determineFontSizeToFit({\n      text: cellLabel,\n      referenceFontSize,\n      referenceMeasurement: {\n        maxCharacterHeight: measuredCharacterHeight,\n        maxCharacterWidth: measuredCharacterWidth,\n      },\n      rectangle: {width: fullWidth, height: fullAvailableHeightForLabel},\n    });\n    if (layoutResultWithoutMargin.fontSize > minNodeNameFontSize) {\n      const textSplitIntoLines = layoutResultWithoutMargin.lines.map(line => line.text);\n      labelLayout = {\n        showText: true,\n        fontSize: layoutResultWithoutMargin.fontSize,\n        textSplitIntoLines,\n        textUnsplit: textSplitIntoLines.join(' '),\n        useMargin: false,\n      };\n    } else {\n      // When removing margin still doesn't fit the text, truncate the text if\n      // the height can accommodate at least three lines of text:\n      if (fullAvailableHeightForLabel > 3 * maxCharacterHeightAtMinFontSize) {\n        const truncatedLines = truncateTextInRectangle({\n          text: cellLabel,\n          referenceFontSize,\n          referenceMeasurement: {\n            maxCharacterHeight: measuredCharacterHeight,\n            maxCharacterWidth: measuredCharacterWidth,\n          },\n          rectangle: {width: fullWidth, height: fullAvailableHeightForLabel},\n          fontSizeToTry: minNodeNameFontSize,\n        });\n        if (truncatedLines.length > 0) {\n          const textSplitIntoLines = truncatedLines.map(line => line.text);\n          labelLayout = {\n            showText: true,\n            fontSize: minNodeNameFontSize,\n            textSplitIntoLines,\n            textUnsplit: textSplitIntoLines.join(' '),\n            useMargin: false,\n          };\n        } else {\n          labelLayout = {showText: false};\n        }\n      } else {\n        labelLayout = {showText: false};\n      }\n    }\n  }\n  //#endregion\n\n  //#region Percentage layout:\n  const heightAvailableForPercentage = fullHeight * heightProportionReservedForShare;\n  let textLayout: TextLayout, shareLayout: ShareLayout;\n  if (labelLayout.showText === true) {\n    // If layout for label is succesful, only use the space that's reserved for\n    // the percentage:\n    const layoutResultPartialCell = determineFontSizeToFit({\n      text: cellValue,\n      referenceFontSize,\n      referenceMeasurement: {\n        maxCharacterHeight: measuredCharacterHeight,\n        maxCharacterWidth: measuredCharacterWidth,\n      },\n      rectangle: {width: fullWidth, height: heightAvailableForPercentage},\n    });\n\n    // Make sure that the percentage doesn't extend more than one line:\n    if (layoutResultPartialCell.fontSize > minNodeNameFontSize &&\n        layoutResultPartialCell.lines.length <= 1) {\n\n      shareLayout = {\n        showText: true,\n        fontSize: layoutResultPartialCell.fontSize,\n        text: cellValue,\n      };\n      textLayout = {\n        type: TextLayoutType.ShowBoth,\n        share: shareLayout,\n        label: labelLayout,\n      };\n    } else {\n      shareLayout = {\n        showText: false,\n      };\n      textLayout = {\n        type: TextLayoutType.ShowNone,\n      };\n    }\n  } else {\n    // If label text is not shown, let the percentage take up the entire space:\n    const layoutResultFullCell = determineFontSizeToFit({\n      text: cellValue,\n      referenceFontSize,\n      referenceMeasurement: {\n        maxCharacterHeight: measuredCharacterHeight,\n        maxCharacterWidth: measuredCharacterWidth,\n      },\n      rectangle: {width: fullWidth, height: fullHeight},\n    });\n\n    if (layoutResultFullCell.fontSize > minNodeNameFontSize &&\n        layoutResultFullCell.lines.length <= 1) {\n\n      shareLayout = {\n        showText: true,\n        fontSize: layoutResultFullCell.fontSize,\n        text: cellValue,\n      };\n      textLayout = {\n        type: TextLayoutType.ShowOnlyShare,\n        share: shareLayout,\n      };\n    } else {\n      textLayout = {\n        type: TextLayoutType.ShowNone,\n      };\n    }\n  }\n\n  //#endregion\n\n  const result: WithTextLayout<T> = {\n    ...datum,\n    textLayout,\n  };\n\n  return result;\n};\n\nexport default addTextLayout;\n","import sortBy from 'lodash/sortBy';\nimport sum from 'lodash/sum';\nimport squarify, {\n  Input,\n  IRect,\n} from 'squarify';\nimport {\n  groupByMap,\n} from './Utils';\n\nexport type WithRect<T> = T & {\n  x0: number;\n  y0: number;\n  x1: number;\n  y1: number;\n};\ninterface IWithTopLevelParentId {\n  monetaryValue: number;\n  // id: string\n  // shortName: string\n  topLevelParentId: string;\n}\n\nconst performLayout = <T extends IWithTopLevelParentId>(\n    list: T[], container: IRect,\n  ): Array<WithRect<T>> => {\n\n  type AugmentedElement = T & {value: number, children: undefined};\n\n  const groupedBySection = groupByMap(list, ({topLevelParentId}) => topLevelParentId);\n  const result: Array<Input<T>> = [];\n  for (const [sectionId, elemsInSection] of (groupedBySection as any)) {\n    const sortedElemsInSection = sortBy(elemsInSection, 'monetaryValue').reverse();\n    const elemsWithValue: AugmentedElement[] = sortedElemsInSection.map(elem => ({\n      ...elem,\n      value: elem.monetaryValue,\n      children: undefined,\n    }));\n    const sectionSum = sum(sortedElemsInSection.map(({monetaryValue}) => monetaryValue));\n    const firstElem = elemsWithValue[0];\n    const sectionResult: Input<T> = {\n      // Spread in one element to satisfy the type checker:\n      ...firstElem,\n\n      value: sectionSum,\n      children: elemsWithValue,\n      id: sectionId,\n    };\n    result.push(sectionResult);\n  }\n  const sorted = sortBy(result, 'value').reverse();\n\n  const rawLayoutOutput = squarify<T>(sorted, container);\n  const cleanedOutput = rawLayoutOutput.map(elem => {\n    const {\n      x0, y0, x1, y1, normalizedValue, value, children, ...rest\n    } = elem;\n    const out = {\n      x0, y0, x1, y1,\n      ...rest,\n    } as unknown as WithRect<T>;\n    return out;\n  });\n  return cleanedOutput;\n};\n\nexport default performLayout;\n","import * as React from 'react'\nimport Chart, {IProps} from './chart/chart';\nimport treemapCellTransformer, {Inputs, Output} from './transformers/treemapCellTransformer';\n\nexport const transformData: (inputs: Inputs) => Output = treemapCellTransformer;\n\nexport default (props: IProps) => {\n  return (\n    <Chart {...props} />\n  );\n}\n","import sum from 'lodash/sum';\nimport {formatPercentage } from './numberFormatters';\nimport addTextLayout from '../chart/addTextLayout';\nimport {\n  ITreeMapCell,\n} from '../chart/otherTypes';\nimport performLayout, { WithRect } from '../chart/performLayout';\nimport {\n  computeGrossNetTradeValues,\n  filterByMonetaryValues,\n  maxCharacterHeightAtMinFontSize,\n} from '../chart/transformUtils';\nimport {\n  measuredCharacterHeight,\n  measuredCharacterWidth,\n  referenceFontSize,\n} from '../chart/Utils';\nimport mergeComparisonData, {ComparisonTreeMapCells} from './mergeComparisonData';\n\nexport interface Datum {\n  id: string;\n  value: number;\n  title: string;\n  topLevelParentId: string;\n}\n\nexport interface ComparisonDatum extends Datum {\n  primaryValue: number;\n  secondaryValue: number;\n}\n\ninterface ColorMap {\n  id: string;\n  color: string;\n}\n\nexport interface Inputs {\n  data: Datum[];\n  comparisonData?: Datum[];\n  width: number;\n  height: number;\n  colorMap: ColorMap[];\n}\n\nexport interface Output {\n  treeMapCells: ITreeMapCell[];\n}\n\nexport interface Transformed {\n  id: string;\n  label: string;\n  monetaryValue: number;\n  topLevelParentId: string;\n  percentage: number;\n}\n\nconst treemapCellTransformer = (inputs: Inputs): Output => {\n  const {\n    width, height, colorMap,\n  } = inputs;\n  let data: (Datum[]) | (ComparisonDatum[]);\n  let createComparisionCells: ((layoutCell: ITreeMapCell) => ComparisonTreeMapCells) | undefined;\n  if (inputs.comparisonData !== undefined) {\n    const merged = mergeComparisonData(inputs.data, inputs.comparisonData);\n    data = merged.data;\n    createComparisionCells = merged.createComparisionCells;\n  } else {\n    data = inputs.data;\n    createComparisionCells = undefined;\n  }\n  const withComputedTradeValues = computeGrossNetTradeValues(data);\n  const filteredByMonetaryValue = filterByMonetaryValues(withComputedTradeValues);\n  const totalSum = sum(filteredByMonetaryValue.map(({monetaryValue}) => monetaryValue));\n  const transformed: Transformed[] = [];\n  for (const elem of filteredByMonetaryValue) {\n    const {\n      monetaryValue, topLevelParentId, id, title,\n    } = elem;\n    const percentage = monetaryValue / totalSum;\n\n    const out: Transformed = {\n      id,\n      label: title,\n      monetaryValue,\n      topLevelParentId,\n      percentage,\n    };\n    transformed.push(out);\n\n  }\n  const container = {\n    x0: 0, y0: 0, x1: width, y1: height,\n  };\n  const withCellLayout: Array<WithRect<Transformed>> = performLayout(transformed, container);\n  const withTextLayout = withCellLayout.map(elem => {\n    const cellValue: string = formatPercentage(elem.percentage);\n    return addTextLayout({\n      datum: elem,\n      referenceFontSize, measuredCharacterHeight,\n      measuredCharacterWidth, maxCharacterHeightAtMinFontSize,\n      cellLabel: elem.label,\n      cellValue,\n    });\n  });\n\n  let treeMapCells: ITreeMapCell[] = [];\n  withTextLayout.forEach(({topLevelParentId, monetaryValue, ...rest}) => {\n    const tagetColor = colorMap.find(c => c.id === topLevelParentId);\n    if (tagetColor === undefined) {\n      throw new Error('Cannot find color for top section ' + topLevelParentId);\n    }\n    const out: ITreeMapCell = {\n      ...rest,\n      color: tagetColor.color,\n      value: monetaryValue,\n    };\n    if (inputs.comparisonData !== undefined && createComparisionCells !== undefined) {\n      const mergedCells = createComparisionCells(out)\n      mergedCells.forEach(cell => treeMapCells.push(cell));\n    } else {\n      treeMapCells.push(out);\n    }\n  });\n\n  return {treeMapCells};\n};\n\nexport default treemapCellTransformer;\n\n","import {\n  Datum,\n  ComparisonDatum,\n} from './treemapCellTransformer';\nimport {\n  ITreeMapCell,\n  TextLayoutType,\n  TextLayout,\n} from '../chart/otherTypes';\nimport {lighten} from 'polished';\n\ntype TextCell = ITreeMapCell;\ntype PrimaryCell = ITreeMapCell;\ntype SecondaryCell = ITreeMapCell;\ntype BorderBottomCell = ITreeMapCell;\ntype BorderRightCell = ITreeMapCell;\n\nexport type ComparisonTreeMapCells = [\n  TextCell,\n  PrimaryCell,\n  SecondaryCell,\n  BorderBottomCell,\n  BorderRightCell,\n]\n\ninterface Output {\n  data: ComparisonDatum[];\n  createComparisionCells: (layoutCell: ITreeMapCell) => ComparisonTreeMapCells;\n}\n\nexport default (primaryData: Datum[], secondaryData: Datum[]): Output => {\n  // merge all data points from dataset 2 into dataset 1\n  const data = primaryData.map(d1 => {\n    const d2 = secondaryData.find(({id}) => id === d1.id);\n    const secondaryValue = d2 && d2.value ? d2.value : 0;\n    return {...d1, value: d1.value + secondaryValue, primaryValue: d1.value, secondaryValue};\n  })\n  // Add any datapoints that only exist in dataset 2\n  secondaryData.filter(({id}) => !primaryData.find(d => d.id === id))\n               .forEach(d => data.push({...d, primaryValue: 0, secondaryValue: d.value}));\n\n  const createComparisionCells = (layoutCell: ITreeMapCell): ComparisonTreeMapCells => {\n    const targetDatum = data.find(({id}) => id === layoutCell.id);\n    if (!targetDatum) {\n      console.error({'Invalid cell': layoutCell});\n      throw new Error('Invalid layoutCell id ' + layoutCell.id + 'at mergeComparisonData');\n    }\n    let textLayout: TextLayout;\n    if (layoutCell.textLayout.type === TextLayoutType.ShowBoth) {\n      textLayout = {\n        type: TextLayoutType.ShowBoth,\n        label: {...layoutCell.textLayout.label},\n        share: {showText: false},\n      }\n    } else {\n      textLayout = { type: TextLayoutType.ShowNone };\n    }\n    const textCell: TextCell = {\n      ...layoutCell,\n      id: 'text-cell-' + layoutCell.id,\n      textLayout,\n      color: 'transparent',\n    }\n    const primaryCell: PrimaryCell = {\n      ...layoutCell,\n      id: 'primary-cell-' + layoutCell.id,\n      x1: layoutCell.x1 - ((layoutCell.x1 - layoutCell.x0) * (targetDatum.secondaryValue / targetDatum.value)),\n      textLayout: { type: TextLayoutType.ShowNone },\n      comparison: true,\n    }\n    const secondaryCell: SecondaryCell = {\n      ...layoutCell,\n      id: 'secondary-cell-' + layoutCell.id,\n      x0: primaryCell.x1,\n      color: lighten(0.1, layoutCell.color),\n      textLayout: { type: TextLayoutType.ShowNone },\n      comparison: true,\n    }\n    const borderBottom: BorderBottomCell = {\n      ...layoutCell,\n      id: 'border-bottom-' + layoutCell.id,\n      y0: layoutCell.y1 - 0.5,\n      color: 'white',\n      comparison: true,\n      textLayout: { type: TextLayoutType.ShowNone },\n    }\n    const borderRight: BorderRightCell = {\n      ...layoutCell,\n      id: 'border-right-' + layoutCell.id,\n      x0: layoutCell.x1 - 0.5,\n      color: 'white',\n      comparison: true,\n      textLayout: { type: TextLayoutType.ShowNone },\n    }\n    return [textCell, primaryCell, secondaryCell, borderBottom, borderRight];\n  }\n  return {data, createComparisionCells};\n}\n\n","import {\n  format,\n} from 'd3-format';\n\nexport const formatPercentage =\n  (percentage: number, decimalPlaces: number = 2) => format(`.${decimalPlaces}%`)(percentage);\n","import React, {useState} from 'react'\nimport raw from 'raw.macro';\nimport TreeMap, {transformData} from 'react-canvas-treemap';\nimport styled from 'styled-components/macro';\n\nconst Grid = styled.div`\n  display: grid;\n  grid-template-columns: 500px 500px;\n  grid-gap: 1rem;\n  margin-bottom: 2rem;\n`;\n\nconst destBostonDataRaw = JSON.parse(raw('../data/treemap_dest_boston_all_industry.json'));\n\nlet colorMap: Array<{id: string, color: string}> = [];\ndestBostonDataRaw.forEach(({topLevelParentId, color}: {topLevelParentId: string, color: string}) => {\n  if (!colorMap.find(({id}) => id === topLevelParentId)) {\n    colorMap.push({id: topLevelParentId, color});\n  }\n})\n\nconst destBostonData = transformData({\n  data: destBostonDataRaw,\n  width: 500,\n  height: 500,\n  colorMap: colorMap,\n});\n\n\nconst originBostonDataRaw = JSON.parse(raw('../data/treemap_origin_boston_all_industry.json'));\n\nconst originBostonData = transformData({\n  data: originBostonDataRaw,\n  width: 500,\n  height: 500,\n  colorMap: colorMap,\n});\n\n\nconst employeeBostonDataRaw = JSON.parse(raw('../data/boston_dest_employees.json'));\n\nlet cityColorMap: Array<{id: string, color: string}> = [];\nemployeeBostonDataRaw.forEach(({topLevelParentId, color}: {topLevelParentId: string, color: string}) => {\n  if (!cityColorMap.find(({id}) => id === topLevelParentId)) {\n    cityColorMap.push({id: topLevelParentId, color});\n  }\n})\n\nconst employeeBostonData = transformData({\n  data: employeeBostonDataRaw,\n  width: 500,\n  height: 500,\n  colorMap: cityColorMap,\n});\n\nconst filteredToUSA = employeeBostonDataRaw.filter(({topLevelParentId}: {topLevelParentId: string}) => topLevelParentId === 'USA');\n\nconst filteredBostonData = transformData({\n  data: filteredToUSA,\n  width: 500,\n  height: 500,\n  colorMap: cityColorMap,\n});\n\n\nenum NumCellsTier {\n  // Use `Small` for all type of tree maps except for product tree maps at\n  // 6-digit detail level:\n  Small,\n  Large,\n}\n\n\nenum Direction {\n  Dest,\n  Origin,\n}\n\nconst App = () => {\n  const [direction, setDirection] = useState<Direction>(Direction.Dest);\n  const [filtered, setFiltered] = useState<boolean>(false);\n\n  const toggleDirection = () => {\n    if (direction === Direction.Dest) {\n      setDirection(Direction.Origin);\n    } else {\n      setDirection(Direction.Dest);\n    }\n  }\n\n  return (\n    <div>\n      <Grid>\n        <div>\n          <button onClick={toggleDirection}>\n            Toggle Data\n          </button>\n          <TreeMap\n            highlighted={undefined}\n            cells={direction === Direction.Dest ? destBostonData.treeMapCells : originBostonData.treeMapCells}\n            numCellsTier={NumCellsTier.Small}\n            chartContainerWidth={500}\n            chartContainerHeight={500}\n            onCellClick={id => console.log(id)}\n            onMouseOverCell={id => console.log(id)}\n            onMouseLeaveChart={() => {}}\n          />\n        </div>\n        <div>\n          <button onClick={() => setFiltered(!filtered)}>\n            Toggle Filter\n          </button>\n          <TreeMap\n            highlighted={undefined}\n            cells={filtered ? filteredBostonData.treeMapCells : employeeBostonData.treeMapCells}\n            numCellsTier={NumCellsTier.Small}\n            chartContainerWidth={500}\n            chartContainerHeight={500}\n            onCellClick={id => console.log(id)}\n            onMouseOverCell={id => console.log(id)}\n            onMouseLeaveChart={() => {}}\n          />\n        </div>\n      </Grid>\n    </div>\n  );\n}\n\nexport default App\n","import React, {useState} from 'react'\nimport raw from 'raw.macro';\nimport TreeMap, {transformData} from 'react-canvas-treemap';\nimport styled from 'styled-components/macro';\n\nconst Container = styled.div`\n  width: 500px;\n  height: 500px;\n  margin-bottom: 2rem;\n`;\n\nconst Nav = styled.nav`\n  display: flex;\n`;\n\nconst Button = styled.button`\n  margin-right: 1rem;\n  cursor: pointer;\n`;\n\ninterface NaicsDatum {\n  code: string;\n  code_hierarchy: string;\n  level: number;\n  naics_id: number;\n  naics_id_hierarchy: string;\n  name: string;\n  parent_code: null | string;\n  parent_id: null | number;\n}\n\nconst naicsData: NaicsDatum[] = JSON.parse(raw('../data/naics_2017.json'));\n\nconst colorMap = [\n  { id: '0', color: '#2b005c' },\n  { id: '1', color: '#630061' },\n  { id: '2', color: '#91005e' },\n  { id: '3', color: '#b90056' },\n  { id: '4', color: '#d92649' },\n  { id: '5', color: '#f05238' },\n  { id: '6', color: '#fc7c23' },\n  { id: '7', color: '#ffa600' },\n  { id: '8', color: 'red' },\n]\n\ninterface RawDatum {\n  id: number,\n  city_id: number,\n  year: number,\n  naics_id: number,\n  num_employ: number,\n  num_company: number,\n  level: number,\n}\n\nconst rawData: RawDatum[][]  = [\n  JSON.parse(raw('../data/boston_naics_sample/boston_sample_naics_1.json')),\n  JSON.parse(raw('../data/boston_naics_sample/boston_sample_naics_2.json')),\n  JSON.parse(raw('../data/boston_naics_sample/boston_sample_naics_3.json')),\n  JSON.parse(raw('../data/boston_naics_sample/boston_sample_naics_4.json')),\n  JSON.parse(raw('../data/boston_naics_sample/boston_sample_naics_5.json')),\n  JSON.parse(raw('../data/boston_naics_sample/boston_sample_naics_6.json')),\n]\n\ninterface PreparedDatum {\n  id: string,\n  title: string,\n  value: number,\n  topLevelParentId: string,\n}\n\nconst data: PreparedDatum[][] = rawData.map(d => d.map(({naics_id, num_company}) => {\n  let topLevelParentId: string = naics_id.toString();\n  let current: NaicsDatum | undefined = naicsData.find(datum => datum.naics_id === naics_id);\n  const title = current && current.name ? current.name : 'Unknown';\n  while(current && current.parent_id !== null) {\n    // eslint-disable-next-line\n    current = naicsData.find(datum => datum.naics_id === (current as NaicsDatum).parent_id);\n    if (current && current.parent_id !== null) {\n      topLevelParentId = current.parent_id.toString();\n    } else if (current && current.naics_id !== null) {\n      topLevelParentId = current.naics_id.toString();\n    }\n  }\n  if (parseInt(topLevelParentId, 10) > 8) {\n    console.error(current);\n    throw new Error('Parent out of range')\n  }\n\n  return {\n    id: naics_id.toString(),\n    title,\n    value: num_company,\n    topLevelParentId,\n  }\n}));\n\nconst width = 800;\nconst height = 600;\n\nconst transformedData = data.map(d => transformData({\n  data: d,\n  width,\n  height,\n  colorMap: colorMap,\n}))\n\nenum NumCellsTier {\n  // Use `Small` for all type of tree maps except for product tree maps at\n  // 6-digit detail level:\n  Small,\n  Large,\n}\n\nconst App = () => {\n  const [digit, setDigit] = useState<number>(0);\n\n  const tooltipContent = (id: string) => {\n    const current: NaicsDatum | undefined = naicsData.find(datum => datum.naics_id.toString() === id);\n    if (current) {\n      return current.name;\n    } else {\n      return id;\n    }\n  }\n\n  return (\n    <div>\n      <Nav>\n        <Button\n          onClick={() => setDigit(0)}\n        >\n          1-digit\n        </Button>\n        <Button\n          onClick={() => setDigit(1)}\n        >\n          2-digit\n        </Button>\n        <Button\n          onClick={() => setDigit(2)}\n        >\n          3-digit\n        </Button>\n        <Button\n          onClick={() => setDigit(3)}\n        >\n          4-digit\n        </Button>\n        <Button\n          onClick={() => setDigit(4)}\n        >\n          5-digit\n        </Button>\n        <Button\n          onClick={() => setDigit(5)}\n        >\n          6-digit\n        </Button>\n      </Nav>\n      <h3>{digit + 1}-digit</h3>\n      <Container>\n        <TreeMap\n          highlighted={undefined}\n          cells={transformedData[digit].treeMapCells}\n          numCellsTier={NumCellsTier.Small}\n          chartContainerWidth={width}\n          chartContainerHeight={height}\n          onCellClick={id => alert('Clicked: ' + tooltipContent(id))}\n          onMouseOverCell={id => console.log('Hovered on: ' + tooltipContent(id))}\n          onMouseLeaveChart={() => {}}\n        />\n      </Container>\n    </div>\n  );\n}\n\nexport default App\n","import React from 'react'\nimport raw from 'raw.macro';\nimport TreeMap, {\n  transformData\n} from 'react-canvas-treemap';\n\nconst colorMap = [\n  { id: '0', color: '#2b005c' },\n  { id: '1', color: '#630061' },\n  { id: '2', color: '#91005e' },\n  { id: '3', color: '#b90056' },\n  { id: '4', color: '#d92649' },\n  { id: '5', color: '#f05238' },\n  { id: '6', color: '#fc7c23' },\n  { id: '7', color: '#ffa600' },\n  { id: '8', color: 'red' },\n]\n\ninterface NaicsDatum {\n  naics_id: number,\n  code: string,\n  name: string,\n  level: number,\n  parent_id: number | null,\n  parent_code: string | null,\n  code_hierarchy: string,\n  naics_id_hierarchy: string,\n}\n\nconst naicsData: NaicsDatum[] = JSON.parse(raw('../data/naics_2017.json'));\n\ninterface RawDatum {\n  id: string,\n  title: string,\n  value: number,\n  topLevelParentId: string,\n}\n\nconst bostonData: RawDatum[] = [];\nJSON.parse(raw('../data/boston-3digit-shares.json'))\n  .forEach(({naics_id, num_employ}: {naics_id: number, num_employ: number}) => {\n    const industry = naicsData.find(d => d.naics_id === naics_id);\n    let topLevelParentId: string = naics_id.toString();\n    let current: NaicsDatum | undefined = naicsData.find(datum => datum.naics_id === naics_id);\n    while(current && current.parent_id !== null) {\n      // eslint-disable-next-line\n      current = naicsData.find(datum => datum.naics_id === (current as NaicsDatum).parent_id);\n      if (current && current.parent_id !== null) {\n        topLevelParentId = current.parent_id.toString();\n      } else if (current && current.naics_id !== null) {\n        topLevelParentId = current.naics_id.toString();\n      }\n    }\n    if (parseInt(topLevelParentId, 10) > 8) {\n      console.error(current);\n      throw new Error('Parent out of range')\n    }\n    if (industry) {\n      bostonData.push({\n        id: naics_id.toString(),\n        title: industry.name,\n        value: num_employ,\n        topLevelParentId,\n      })\n    }\n  });\n\nconst newYorkData: RawDatum[] = [];\nJSON.parse(raw('../data/newyork-3digit-shares.json'))\n  .forEach(({naics_id, num_employ}: {naics_id: number, num_employ: number}) => {\n    const industry = naicsData.find(d => d.naics_id === naics_id);\n    let topLevelParentId: string = naics_id.toString();\n    let current: NaicsDatum | undefined = naicsData.find(datum => datum.naics_id === naics_id);\n    while(current && current.parent_id !== null) {\n      // eslint-disable-next-line\n      current = naicsData.find(datum => datum.naics_id === (current as NaicsDatum).parent_id);\n      if (current && current.parent_id !== null) {\n        topLevelParentId = current.parent_id.toString();\n      } else if (current && current.naics_id !== null) {\n        topLevelParentId = current.naics_id.toString();\n      }\n    }\n    if (parseInt(topLevelParentId, 10) > 8) {\n      console.error(current);\n      throw new Error('Parent out of range')\n    }\n    if (industry) {\n      newYorkData.push({\n        id: naics_id.toString(),\n        title: industry.name,\n        value: num_employ,\n        topLevelParentId,\n      })\n    }\n  });\n\nconst width = 800;\nconst height = 600;\n\nconst transformedData = transformData({\n  data: bostonData,\n  comparisonData: newYorkData,\n  width,\n  height,\n  colorMap,\n});\n\nenum NumCellsTier {\n  // Use `Small` for all type of tree maps except for product tree maps at\n  // 6-digit detail level:\n  Small,\n  Large,\n}\n\nconst App = () => {\n  return (\n    <div style={{display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh'}}>\n      <TreeMap\n        highlighted={undefined}\n        cells={transformedData.treeMapCells}\n        numCellsTier={NumCellsTier.Small}\n        chartContainerWidth={width}\n        chartContainerHeight={height}\n        onCellClick={id => console.log(id)}\n        onMouseOverCell={id => console.log(id)}\n        onMouseLeaveChart={() => {}}\n      />\n    </div>\n  );\n}\n\nexport default App\n","import React from 'react'\nimport {\n  HashRouter as Router,\n  Route,\n  Switch,\n} from 'react-router-dom';\nimport Landing from './pages/Landing';\nimport ToggleDemo from './pages/ToggleDemo';\nimport DigitDemo from './pages/DigitDemo';\nimport ComparisonDemo from './pages/ComparisonDemo';\n\nconst App = () => {\n\n  return (\n    <div>\n      <Router>\n          <Switch>\n              <Route exact path={'/toggle'} component={ToggleDemo} />\n              <Route exact path={'/digit'} component={DigitDemo} />\n              <Route exact path={'/compare'} component={ComparisonDemo} />\n            <Route component={Landing} />\n          </Switch>\n        </Router>\n    </div>\n  );\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}