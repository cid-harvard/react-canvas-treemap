{"version":3,"sources":["pages/Landing.tsx","../../src/chart/Queue.ts","../../src/chart/DOMPool.ts","../../src/chart/Utils.ts","../../src/chart/webglUtils.ts","../../src/chart/otherTypes.ts","../../src/chart/transformUtils.ts","../../src/chart/domIndependentDrawUtils.ts","../../src/chart/domDependentDrawUtils.ts","../../src/chart/useTrackingRef.ts","../../src/chart/chart.tsx","../../src/chart/usePropsChangeRateLimiter.ts","../../src/chart/fitTextInRectangle.ts","../../src/chart/addTextLayout.ts","../../src/chart/performLayout.ts","../../src/index.tsx","../../src/transformers/treemapCellTransformer.ts","../../src/transformers/mergeComparisonData.ts","../../src/transformers/numberFormatters.ts","pages/ToggleDemo.tsx","pages/DigitDemo.tsx","pages/ComparisonDemo.tsx","App.tsx","index.tsx"],"names":["ListItem","styled","li","to","queue","offset","this","length","Error","item","DOMPool","constructor","size","tagName","i","elem","document","failIfValidOrNonExhaustive","_variable","message","ellipsisCharacter","String","UpdateType","PersistentFloat32Array","maxLength","Float32Array","buffer","subarray","theirBuffer","ourBuffer","theirLength","resizeViewport","gl","pixelRatio","window","canvas","displayWidth","Math","displayHeight","shouldResizeCanvas","compileShader","shader","createProgramFromShaderSource","program","createProgram","vertexShaderSource","fragmentShaderSource","GL_NUM_BYTES_PER_FLOAT","IndexElementType","AttributeLocationRequestType","AttributeBufferRequestType","WebGLVersion","TextLayoutType","applyStyleToDOMNode","domNode","textStyle","NumCellsTier","getColorTripletFromColorString","colorString","unnormalized","color","rectangleReferencePositionValues","rectangleIndices","rectangleIndicesCount","value","ref","useRef","useEffect","console","Root","normalizedStrokeColor","AnimationStatus","createCellsBuffer","numCellsTier","numCells","setupWebGL","input","canvasRef","current","cellProgramRef","alpha","glInfoRef","vaoExtension","instancedDrawingExtension","cellBuffer","cellsVAO","bindBuffer","bufferDataToBind","rebindBuffer","createPopulatedGLBuffer","rebindGLBuffer","indexBuffer","vertexShader","attributeInfo","attributeName","attributeRequest","location","bufferRequest","createdBuffer","totalSizeAsNumOfFloats","numFloatsPerVertex","stride","thisAttributeInfo","indexSize","indexElementType","dummyDataAsBinary","Uint16Array","indexElementTypeForDrawCall","Uint32Array","indicesBuffer","indexBufferInfo","elementType","uniformLocations","uniformName","result","version","attributes","uniforms","uniformBlockRequests","uniformBlockInfo","assignedBuffer","blockIndex","blockInfo","uniformBlocks","getProgramInfo","fragmentShader","name","type","isInstanced","cellGLBuffer","totalSizeAsNumOfInts","vaoObject","timerExtension","upgradeToLargeBuffer","glInfo","newCellBuffer","performPropsChange","inputWidth","extraInputs","rootEl","rootElRef","cellProgram","prevStatus","statusRef","upgradeBuffer","upgradeToLargeBufferRef","done","halfStrokeWidth","nextValue","prevValue","hasChartSizeChanged","prevCells","prevCellsLength","nextCells","prevCell","nextCell","haveCellsChanged","prevKeys","prevTextContainer","prevAttachedDOMNodes","programInfo","sendAttributesToGPUWithVAO","data","sendIndicesToGPUWithVAO","cellList","nextKeys","cellListLength","someCellHighlighted","highlighted","cell","id","x0","y0","x1","y1","isComparisonCell","textLayout","retrievedColor","colorTriplet","desaturate","internalCell","fillColor","strokeOpacity","convertToInternalCells","updatePattern","prevKeysSet","Set","nextKeysSet","getUpdateType","key","inPrev","inNext","prevKeysLength","nextKeysLength","prevKeysPending","pendingKeys","nextKey","lastPendingKey","childMapping","j","prevKey","retrievedPrevKeysPending","retrievedPrevKeyPendingLength","k","pendingPrevKey","pendingKeysLength","m","retrievedPendingKey","getUpdatePattern","cellsInfo","updatePatternLength","actualBuffer","numFloatsPerCellInstance","initialTopLeftX","initialTopLeftY","finalTopLeftX","finalTopLeftY","initialBottomRightX","initialBottomRightY","finalBottomRightX","finalBottomRightY","initialFillColor","finalFillColor","initialStrokeColor","finalStrokeColor","strokeWidth","strokeColor","numFloatsPerCell","numFloatsSetPerInstanceSoFar","instancesCount","writeToCellBuffers","updateGLBuffer","doesNextUpdateHaveData","intervalTrees","xIntervals","yIntervals","xInterval","yInterval","xIntervalTree","createIntervalTree","yIntervalTree","getIntervalTrees","nextXIntervalTree","nextYIntervalTree","tweenTarget","tweenProgress","timeline","paused","childrenNodes","cellWidth","cellHeight","percentageClassName","share","heightAvailableForLabel","label","paddingTop","horizontalPadding","labelElem","pool","className","textContent","top","left","width","height","fontSize","paddingLeft","paddingRight","heightAvailableForPercentage","shareElem","fragment","rootNode","childrenNodesLength","allCurrentlyAttachedDOMNodes","getTextLabelFragment","domPoolRef","textContainerStatus","isTextContainerChanging","prevContainer","nextAttachedDOMNodes","nextContainer","currentAttachedDOMNodes","currentTextContainer","css","opacity","durationInSeconds","onAnimationComplete","endProspChangeTransition","status","currentCells","currentKeys","cellIndicesCount","cellInstancesCount","newAttachedDOMNOdes","newTextContainer","domNodesToRemove","textContainerToRemove","requestAnimationFrame","domPool","prevAttachedDOMNodesLength","animationTween","transitionDuration","ease","onUpdate","onComplete","setupVisibleDraw","performHitTest","chartHeight","mouseClientX","mouseClientY","chartWidth","xTarget","yTarget","xMatchIds","interval","yMatchIds","numXMatches","numYMatches","xId","searchForHits","props","Initial","once","chartContainerWidth","chartWidthRef","useTrackingRef","chartHeightRef","onMouseOverCellRef","onMouseLeaveChartRef","heightInCSSPixelsRef","widthInCSSPixelsRef","setWidthHeightInCSSPixels","innerGLInfo","isTransitionInProgress","nextValueRef","prevValueRef","isTransitionInProgressRef","onPropsChangeComplete","performNextValueChange","getExtraInputToPropsChangeHandler","usePropsChangeRateLimiter","cells","chartContainerHeight","comparisonTreeMap","mouseClientXRef","mouseClientYRef","unthrottledHoverHandler","prevHoveredNode","nextHoveredNode","hoveredNode","onMouseOverCell","onMouseLeaveChart","getUnthrottledHoverHandler","throttledPerformHoverRef","throttle","millisecondsPerSeconds","onMouseLeave","throttledHover","cancel","onMouseMove","clientY","throttledPerformHover","onClick","style","attemptFitTextInsideRectangle","fontSizeToTry","maxCharacterHeight","referenceMeasurement","maxCharacterWidth","maxLineNumber","words","text","word","success","lines","fitResult","lineLengthLeft","firstWord","remainingWords","wordToFit","lastFitResult","wordsInLine","wordsBeforeLast","initial","lastWord","last","newWordsBeforeLast","newWords","determineFontSizeToFit","rectangle","totalTextArea","totalRectangleArea","upperBound","lowerBound","layoutAttempt","referenceFontSize","sizeToTry","newUpperBound","newLowerBound","layoutResult","addTextLayout","cellValue","fullWidth","fullHeight","fullAvailableHeightForLabel","labelLayoutWithMargin","measuredCharacterWidth","textSplitIntoLines","line","labelLayout","showText","textUnsplit","useMargin","layoutResultWithoutMargin","truncatedLines","maxCharacterCountToFitWidth","trimmedFirstWord","maxNumOfLines","retainedLines","linesBeforeLast","lastLine","sum","wordsOtherThanLast","newLastWord","newLastLine","truncateTextInRectangle","layoutResultPartialCell","shareLayout","ShowNone","layoutResultFullCell","performLayout","groupedBySection","collection","iteratee","groupByMap","list","topLevelParentId","sortedElemsInSection","sortBy","elemsInSection","elemsWithValue","children","undefined","sectionSum","monetaryValue","firstElem","sectionResult","sectionId","sorted","squarify","rest","transformData","inputs","colorMap","merged","primaryData","d1","d2","secondaryData","secondaryValue","primaryValue","d","createComparisionCells","layoutCell","targetDatum","textCell","primaryCell","comparison","lighten","mergeComparisonData","filteredByMonetaryValue","filterByMonetaryValues","totalSum","transformed","out","title","percentage","withTextLayout","decimalPlaces","format","formatPercentage","datum","measuredCharacterHeight","maxCharacterHeightAtMinFontSize","cellLabel","treeMapCells","tagetColor","c","mergedCells","React","Grid","div","destBostonDataRaw","JSON","parse","forEach","find","push","destBostonData","originBostonData","employeeBostonDataRaw","cityColorMap","Direction","employeeBostonData","filteredBostonData","filter","App","useState","Dest","direction","setDirection","filtered","setFiltered","Origin","Small","onCellClick","log","Container","Nav","nav","Button","button","naicsData","rawData","bosData","1","2","3","4","5","6","nyData","bostonTotal","newYorkTotal","naics_id","num_company","level","city_id","year","toString","parent_id","parseInt","error","City","transformedBosData","transformedNyData","comparisonData","map","Boston","city","setCity","digit","setDigit","tooltipContent","dataset","NewYork","disabled","Comparison","alert","bostonData","num_employ","industry","newYorkData","transformedData","transformedPercentData","display","justifyContent","alignItems","flexDirection","marginBottom","marginRight","exact","path","component","ToggleDemo","DigitDemo","ComparisonDemo","Landing","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.4214b87d.chunk.js","sourcesContent":["import React from 'react';\nimport styled from 'styled-components/macro';\nimport { Link } from 'react-router-dom';\n\nconst ListItem = styled.li`\n  font-size: 1rem;\n  margin-bottom: 0.85rem;\n\n  a {\n    color: rgb(78, 140, 141); \n    text-decoration: none;\n    border-bottom: solid 1px rgb(78, 140, 141);\n  }\n`;\n\nexport default () => {\n  return (\n    <ul>\n      <ListItem><Link to={'/toggle'}>Toggle data demo</Link></ListItem>\n      <ListItem><Link to={'/digit'}>1 - 6 digit demo</Link></ListItem>\n      <ListItem><Link to={'/compare'}>Comparison demo</Link></ListItem>\n    </ul>\n  );\n}\n","// Adapted from http://code.iamkate.com/javascript/queues/.\n\nclass Queue<T> {\n  private queue: T[] = [];\n  private offset = 0;\n\n  getLength() {\n    return this.queue.length - this.offset;\n  }\n\n  isEmpty() {\n    return this.queue.length === 0;\n  }\n\n  enqueue(item: T) {\n    this.queue.push(item);\n  }\n\n  dequeue(): T {\n    let queue = this.queue;\n    let offset = this.offset;\n\n    // if the queue is empty, return immediately\n    if (queue.length === 0) {\n      throw new Error('Cannot dequeue from empty queue');\n    }\n\n    // store the item at the front of the queue\n    const item = queue[offset];\n\n    // increment the offset and remove the free space if necessary\n    if (++ offset * 2 >= queue.length) {\n      queue  = queue.slice(offset);\n      offset = 0;\n    }\n\n    this.queue = queue;\n    this.offset = offset;\n\n    // return the dequeued item\n    return item;\n  }\n\n  /* Returns the item at the front of the queue (without dequeuing it). If the\n   * queue is empty then undefined is returned.\n   */\n  peek(): T {\n    const queue = this.queue;\n    const offset = this.offset;\n\n    if (queue.length <= 0) {\n      throw new Error('Empty queue');\n    }\n\n    return queue[offset];\n  }\n}\n\nexport default Queue;\n","import Queue from './Queue';\n\nexport default class DOMPool {\n  private queue: Queue<HTMLElement> = new Queue<HTMLElement>();\n  constructor(readonly size: number, tagName: string) {\n    const queue = this.queue;\n\n    for (let i = 0; i < size; i += 1) {\n      const elem = document.createElement(tagName);\n      queue.enqueue(elem);\n    }\n  }\n\n  enqueue(elem: HTMLElement) {\n    this.queue.enqueue(elem);\n  }\n\n  dequeue(): HTMLElement {\n    const queue = this.queue;\n    return queue.dequeue();\n  }\n}\n","// Errors out at compile time if a discriminating `switch` doesn't catch all cases\n// of an enum and at run time if for some reason an invalid enum value is passed.\n// See https://basarat.gitbooks.io/typescript/content/docs/types/discriminated-unions.html\nexport function failIfValidOrNonExhaustive(_variable: never, message: string): never {\n  throw new Error(message);\n}\n\nexport const millisecondsPerSeconds = 1_000;\n\nimport {ColorQuadruplet} from './webglUtils';\n\nexport const strokeColor: ColorQuadruplet = [255, 255, 255, 255];\nexport const halfStrokeWidth = 0.5;\n\n// Empirically measured size of character `W` (suposedly the character that\n// takes up the most area) of font \"Source Sans Pro\" at 16px:\nexport const measuredCharacterWidth = 12.3;\nexport const measuredCharacterHeight = 18;\nexport const referenceFontSize = 16;\n\nexport const ellipsisCharacter = String.fromCharCode(0x2026);\n// Like `lodash`'s `groupBy` but the result is an ES6 `Map`\n// instead of an object:\nexport const groupByMap = <Key, Value>(\n  collection: Value[],\n  iteratee: (value: Value) => Key): Map<Key, Value[]> => {\n\n  const result: Map<Key, Value[]> = new Map();\n  collection.forEach(value => {\n    const key = iteratee(value);\n    if (!result.has(key)) {\n      result.set(key, [] as Value[]);\n    }\n    result.get(key)!.push(value);\n  });\n  return result;\n};\n","import {\n  failIfValidOrNonExhaustive,\n} from './Utils';\n\nexport enum UpdateType {\n  Enter = 'Enter',\n  Exit = 'Exit',\n  Update = 'Update',\n}\n\n/* tslint:disable:max-classes-per-file interface-name */\n/* tslint:disable:interface-name */\n// Note: every item of `T` needs to be JSON-serializable\nexport class PersistentArray<T> {\n  data: T[];\n  length: number;\n  constructor(public maxLength: number, initialItem: T) {\n    const stringifiedInitialItem = JSON.stringify(initialItem);\n    const initialData: T[] = [];\n    for (let i = 0; i < maxLength; i += 1) {\n      const item: T = JSON.parse(stringifiedInitialItem);\n      initialData.push(item);\n    }\n    this.length = maxLength;\n    this.data = initialData;\n  }\n\n  // Returns the portion of the array that contains valid information i.e.\n  // excluding \"zeros\" between `this.length` and `this.maxLength`:\n  getMeaningfulData() {\n    return this.data.slice(0, this.length);\n  }\n}\n\n// an array that's intended to not be garbage-collected:\nexport class PersistentFloat32Array {\n  buffer: Float32Array;\n  length: number;\n\n  constructor(public maxLength: number) {\n    this.buffer = new Float32Array(maxLength);\n    this.length = maxLength;\n  }\n\n  // Return the portion of the buffer that contains meaningfully assigned data\n  // (the size of the array buffer is pre-allocated to be always larger than the\n  // size of the actual data it contains).\n  getMeaningfulData(): Float32Array {\n    return this.buffer.subarray(0, this.length);\n  }\n\n  // Copy data from another array (\"they\") of shorter length into this instance (\"we\"):\n  copyFrom(they: PersistentFloat32Array) {\n    const {length: theirLength, buffer: theirBuffer} = they;\n    const {length: ourLength, buffer: ourBuffer} = this;\n    if (theirLength > ourLength) {\n      throw new Error('Not enough space in our array to accommodate data from their array');\n    }\n    for (let i = 0; i < theirLength; i += 1) {\n      ourBuffer[i] = theirBuffer[i];\n    }\n  }\n}\n\n//#region Type definitions for WebGL extensions\nexport interface WebGLTimerQueryEXT {\n  // Fake property to make this type unique:\n  __dummyWebGLTimerQueryEXT: number;\n}\n\nexport interface EXTDisjointTimerQuery {\n  readonly TIME_ELAPSED_EXT: number;\n  readonly QUERY_COUNTER_BITS_EXT: number;\n  readonly CURRENT_QUERY_EXT: number;\n  readonly QUERY_RESULT_EXT: number;\n  readonly QUERY_RESULT_AVAILABLE_EXT: number;\n  readonly TIMESTAMP_EXT: number;\n  readonly GPU_DISJOINT_EXT: number;\n\n  createQueryEXT(): WebGLTimerQueryEXT;\n  beginQueryEXT(num: EXTDisjointTimerQuery['TIME_ELAPSED_EXT'], query: WebGLTimerQueryEXT): void;\n  endQueryEXT(target: number): void;\n  getQueryObjectEXT(query: WebGLTimerQueryEXT, pname: number): any;\n}\n\nexport interface OESElementIndexUint {\n  __dummyOESElementIndexUint: number;\n}\n\nexport interface ANGLEInstancedArrays {\n  readonly VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: number;\n  drawArraysInstancedANGLE(mode: number, first: number, count: number, primcount: number): void;\n  drawElementsInstancedANGLE(mode: number, count: number, type: number, offset: number, primcount: number): void;\n  vertexAttribDivisorANGLE(index: number, divisor: number): void;\n}\n\ninterface WebGLQuery {\n  // Fake property to make this type unique:\n  __dummyWebGLQuery: number;\n}\n\nexport interface EXT_disjoint_timer_query_webgl2 {\n  readonly QUERY_COUNTER_BITS_EXT: number;\n  readonly TIME_ELAPSED_EXT: number;\n  readonly TIMESTAMP_EXT: number;\n  readonly GPU_DISJOINT_EXT: number;\n  queryCounterEXT(query: WebGLQuery, target: number): void;\n  beginQuery(target: number, query?: WebGLQuery): void;\n  endQuery(target: number): void;\n}\n\ndeclare global {\n  interface WebGLRenderingContextBase {\n    getExtension(name: 'EXT_disjoint_timer_query'): EXTDisjointTimerQuery | null;\n  }\n\n  interface WebGL2RenderingContext extends WebGLRenderingContext {\n    // VAO extension:\n    createVertexArray: OES_vertex_array_object['createVertexArrayOES'];\n    deleteVertexArray: OES_vertex_array_object['deleteVertexArrayOES'];\n    isVertexArray: OES_vertex_array_object['isVertexArrayOES'];\n    bindVertexArray: OES_vertex_array_object['bindVertexArrayOES'];\n\n    // Instanced drawing extension:\n    drawArraysInstanced: ANGLE_instanced_arrays['drawArraysInstancedANGLE'];\n    drawElementsInstanced: ANGLE_instanced_arrays['drawElementsInstancedANGLE'];\n    vertexAttribDivisor: ANGLE_instanced_arrays['vertexAttribDivisorANGLE'];\n\n    // Uniform buffer object:\n    getUniformBlockIndex(program: WebGLProgram, uniformBlockName: string): number;\n    uniformBlockBinding(program: WebGLProgram, uniformBlockIndex: number, uniformBlockBinding: number): void;\n    bindBufferBase(target: number, index: number, buffer: WebGLBuffer): void;\n    readonly UNIFORM_BUFFER: number;\n\n    // Query related:\n    createQuery(): WebGLQuery;\n    beginQuery(target: number, query: WebGLQuery): void;\n    endQuery(target: number): WebGLQuery;\n    getQueryParameter(query: WebGLQuery, pname: number): any;\n    readonly QUERY_RESULT_AVAILABLE: number;\n    readonly QUERY_RESULT: number;\n  }\n\n  interface HTMLCanvasElement {\n    getContext(contextId: 'webgl2', contextAttributes?: WebGLContextAttributes): WebGL2RenderingContext | null;\n  }\n}\n//#endregion\n/* tslint:enable:interface-name */\n\nexport type ColorTriplet = [number, number, number];\nexport type ColorQuadruplet = [number, number, number, number];\n\nexport const normalizeColorTriplet = (unnormalized: ColorTriplet): ColorTriplet => ([\n  unnormalized[0] / 255, unnormalized[1] / 255, unnormalized[2] / 255,\n]);\nexport const normalizeColorQuadruplet = (unnormalized: ColorQuadruplet): ColorQuadruplet => ([\n  unnormalized[0] / 255, unnormalized[1] / 255, unnormalized[2] / 255, unnormalized[3] / 255,\n]);\n\nexport const colorTripletToCSSString = (color: ColorTriplet) => `rgb(${color[0]}, ${color[1]}, ${color[2]})`;\n\nexport interface IUpdatePatternItem {\n  key: string;\n  type: UpdateType;\n}\n\n// Adapted from\n// tslint:disable-next-line:max-line-length\n// https://github.com/reactjs/react-transition-group/blob/153d56299903c1d9b85987948dfb410e0e0562e5/src/utils/ChildMapping.js#L39-L83\nexport const getUpdatePattern = (prevKeys: string[], nextKeys: string[]) => {\n  const prevKeysSet = new Set(prevKeys);\n  const nextKeysSet = new Set(nextKeys);\n\n  const getUpdateType = (key: string) => {\n    const inPrev = prevKeysSet.has(key);\n    const inNext = nextKeysSet.has(key);\n    if (inPrev === true && inNext === true) {\n      return UpdateType.Update;\n    } else if (inPrev === true) {\n      return UpdateType.Exit;\n    } else {\n      return UpdateType.Enter;\n    }\n  };\n\n  const prevKeysLength = prevKeys.length;\n  const nextKeysLength = nextKeys.length;\n\n  const prevKeysPending = new Map<string, string[]>();\n\n  let pendingKeys: string[] = [];\n\n  let i = 0;\n  for (i = 0; i < nextKeysLength; i += 1) {\n    const nextKey = nextKeys[i];\n    if (prevKeysSet.has(nextKey)) {\n      if (pendingKeys.length > 0) {\n        prevKeysPending.set(nextKey, pendingKeys);\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(nextKey);\n    }\n  }\n\n  if (pendingKeys.length > 0) {\n    const lastPendingKey = pendingKeys[pendingKeys.length - 1];\n    const index = nextKeys.findIndex(elem => elem === lastPendingKey);\n    if (index < nextKeysLength - 1) {\n      const nextKey = nextKeys[i];\n      prevKeysPending.set(nextKey, pendingKeys);\n      pendingKeys = [];\n    }\n  }\n\n  const childMapping: Map<string, UpdateType> = new Map();\n\n  for (let j = 0; j < prevKeysLength; j += 1) {\n    const prevKey = prevKeys[j];\n    const retrievedPrevKeysPending = prevKeysPending.get(prevKey);\n\n    if (retrievedPrevKeysPending !== undefined) {\n      const retrievedPrevKeyPendingLength = retrievedPrevKeysPending.length;\n      for (let k = 0; k < retrievedPrevKeyPendingLength; k += 1) {\n        const pendingPrevKey = retrievedPrevKeysPending[k];\n        childMapping.set(pendingPrevKey, getUpdateType(pendingPrevKey));\n      }\n    }\n    childMapping.set(prevKey, getUpdateType(prevKey));\n\n  }\n\n  const pendingKeysLength = pendingKeys.length;\n  for (let m = 0; m < pendingKeysLength; m += 1) {\n    const retrievedPendingKey = pendingKeys[m];\n    childMapping.set(retrievedPendingKey, getUpdateType(retrievedPendingKey));\n  }\n\n  const result: IUpdatePatternItem[] = [];\n  for (const [key, type] of (childMapping as any)) {\n    result.push({key, type});\n  }\n\n  return result;\n};\n\nexport const resizeViewport = (gl: WebGLRenderingContext, shouldResizeCanvas: boolean) => {\n  const pixelRatio = window.devicePixelRatio;\n  const canvas = gl.canvas;\n\n  const displayWidth = Math.floor((canvas as any).clientWidth * pixelRatio);\n  const displayHeight = Math.floor((canvas as any).clientHeight * pixelRatio);\n\n  if (shouldResizeCanvas === true) {\n    if (canvas.width !== displayWidth ||\n        canvas.height !== displayHeight) {\n\n        canvas.width = displayWidth;\n        canvas.height = displayHeight;\n    }\n  }\n\n  gl.viewport(0, 0, canvas.width, canvas.height);\n\n};\n\nexport const compileShader = (\n    gl: WebGLRenderingContext, shaderSource: string, shaderType: number,\n  ): WebGLShader => {\n\n  const shader = gl.createShader(shaderType);\n  if (shader === null) {\n    throw new Error('Cannot create shader');\n  }\n  gl.shaderSource(shader, shaderSource);\n  gl.compileShader(shader);\n\n  if (process.env.NODE_ENV !== 'production') {\n    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (success) {\n      return shader;\n    } else {\n      throw new Error('Could not compile shader' + gl.getShaderInfoLog(shader));\n    }\n  }\n\n  return shader;\n\n};\n\nexport const createProgram = (\n    gl: WebGLRenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader,\n  ): WebGLProgram => {\n\n  const program = gl.createProgram();\n  if (program === null) {\n    throw new Error('Cannot create program');\n  }\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  if (process.env.NODE_ENV !== 'production') {\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n    if (success) {\n      return program;\n    } else {\n      throw new Error('Program failed to link: ' + gl.getProgramInfoLog(program));\n    }\n  }\n\n  return program;\n};\n\nexport const createProgramFromShaderSource = (\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n    vertexShaderSource: string,\n    fragmentShaderSource: string,\n  ): WebGLProgram => {\n\n  const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);\n  const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);\n  const program = createProgram(gl, vertexShader, fragmentShader);\n  return program;\n};\n\nexport const sendAttributesToGPUWithVAO = (input: {\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n    programInfo: IProgramInfo,\n    attributeName: string,\n    data: Float32Array,\n  }) => {\n\n  const {\n    gl, data, attributeName,\n    programInfo: {attributes},\n  } = input;\n\n  const info = attributes[attributeName];\n  const buffer = info.buffer;\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferSubData(gl.ARRAY_BUFFER, 0, data);\n};\n\nexport const updateGLBuffer = (input: {\n  gl: WebGLRenderingContext,\n  data: Float32Array,\n  buffer: WebGLBuffer,\n}) => {\n\n  const gl = input.gl;\n  const buffer = input.buffer;\n  const data = input.data;\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferSubData(gl.ARRAY_BUFFER, 0, data);\n};\n\nexport const updateUniformBuffer = (input: {\n    gl: WebGL2RenderingContext,\n    data: Float32Array,\n    buffer: WebGLBuffer,\n  }) => {\n\n  const gl = input.gl;\n  const buffer = input.buffer;\n  const data = input.data;\n\n  gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);\n  gl.bufferSubData(gl.UNIFORM_BUFFER, 0, data);\n};\n\nexport const sendIndicesToGPUWithVAO = (input: {\n    gl: WebGLRenderingContext,\n    programInfo: IProgramInfo\n    data: Uint16Array | Uint32Array,\n  }) => {\n\n  const {\n    gl, data,\n    programInfo: {indexBuffer},\n  } = input;\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer.buffer);\n  gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, data);\n};\n\n// There are 4 bytes in a 32-bit float:\nexport const GL_NUM_BYTES_PER_FLOAT = Float32Array.BYTES_PER_ELEMENT;\n\ninterface IAttributeInfo {\n  location: number;\n  buffer: WebGLBuffer;\n  numFloatsPerVertex: number;\n  stride: number; // in bytes\n  offset: number; // in bytes\n}\n\n// Whether the index buffer allows 16-bit or 32-bit elements:\nexport enum IndexElementType {\n  Int16,\n  Int32,\n}\n\ntype IIndexBufferInfo = {\n  buffer: WebGLBuffer;\n  // Either gl.UNSIGNED_SHORT (16 bit) or gl.UNSIGNED_INT (32 bit)\n  elementType: number;\n};\n\ninterface IUniformBlockInfo {\n  buffer: WebGLBuffer;\n}\n\nexport type IProgramInfo = {\n  program: WebGLProgram;\n  attributes: Record<string, IAttributeInfo>;\n  uniforms: Record<string, WebGLUniformLocation>;\n  indexBuffer: IIndexBufferInfo;\n} & (\n  {version: WebGLVersion.One} |\n  {version: WebGLVersion.Two; uniformBlocks: Record<string, IUniformBlockInfo>}\n);\n\n// `Implicit` means we let WebGL assign the attribute location automatically.\n// `Explicit` means we manually assign a location:\nexport enum AttributeLocationRequestType {\n  Implicit,\n  Explicit,\n}\n\nexport enum AttributeBufferRequestType {\n  Implicit,\n  Explicit,\n}\n\ntype AttributeBufferRequest = {\n  type: AttributeBufferRequestType.Implicit\n  totalSizeAsNumOfFloats: number; // Max num of floats that can fit into this buffer.\n} | {\n  type: AttributeBufferRequestType.Explicit;\n  buffer: WebGLBuffer;\n};\n\nexport interface IAttributeRequest {\n  name: string;\n  // How many floats should be pulled out of this buffer per vertex\n  // e.g. if the attribute is a `vec2`, this number shoudl be 2:\n  numFloatsPerVertex: number;\n  stride: number; // in bytes\n  offset: number; // in bytes\n  buffer: AttributeBufferRequest;\n  isInstanced: boolean;\n}\n\nexport interface IIndexRequest {\n  // Max size of integers (16 or 32 bit) that can fit into the buffer:\n  totalSizeAsNumOfInts: number;\n  elementType: IndexElementType;\n}\n\nexport const createPopulatedGLBuffer = (\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n    bufferData: PersistentFloat32Array) => {\n  const buffer = gl.createBuffer();\n  if (buffer === null) {\n    throw new Error('Cannot create WebGL buffer');\n  }\n\n  const bindBuffer = (bufferDataToBind: PersistentFloat32Array) => {\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, bufferDataToBind.buffer, gl.STATIC_DRAW);\n  };\n  bindBuffer(bufferData);\n\n  return {\n    buffer,\n    rebindBuffer: bindBuffer,\n  };\n};\n\nexport enum WebGLVersion {\n  One,\n  Two,\n}\n\nexport interface IUniformBlockRequest {\n  name: string;\n  assignedBlockIndex: number;\n  assignedBuffer: WebGLBuffer;\n}\n\ntype GetProgramInfoInput = {\n  vertexShader: string,\n  fragmentShader: string,\n  attributes: IAttributeRequest[],\n  uniforms: string[],\n  indexBuffer: IIndexRequest,\n  vaoObject: WebGLVertexArrayObjectOES,\n} & (\n  {\n    version: WebGLVersion.One,\n    gl: WebGLRenderingContext,\n    vaoExtension: OES_vertex_array_object,\n    instancedDrawingExtension: ANGLE_instanced_arrays,\n  } | {\n    version: WebGLVersion.Two,\n    gl: WebGL2RenderingContext,\n    uniformBlocks: IUniformBlockRequest[];\n  }\n);\n\nexport const getProgramInfo = (input: GetProgramInfoInput): IProgramInfo => {\n\n  const {\n    gl, vertexShader, fragmentShader, attributes, uniforms, indexBuffer,\n  } = input;\n\n  const program = createProgramFromShaderSource(gl, vertexShader, fragmentShader);\n\n  if (input.version === WebGLVersion.One) {\n    input.vaoExtension.bindVertexArrayOES(input.vaoObject);\n  } else if (input.version === WebGLVersion.Two) {\n    input.gl.bindVertexArray(input.vaoObject);\n  } else {\n    failIfValidOrNonExhaustive(input, 'Invalid version');\n  }\n\n  // Pre-allocate buffer size for attributes:\n  const attributeInfo: Record<string, IAttributeInfo> = {};\n  for (const attributeRequest of attributes) {\n    const attributeName = attributeRequest.name;\n    const location = input.gl.getAttribLocation(program, attributeName);\n\n    const bufferRequest = attributeRequest.buffer;\n    let buffer: WebGLBuffer;\n    if (bufferRequest.type === AttributeBufferRequestType.Implicit) {\n      const createdBuffer = gl.createBuffer();\n      if (createdBuffer === null) {\n        throw new Error('Cannot create buffer for attribute ' + attributeName);\n      }\n      buffer = createdBuffer;\n      const totalSizeAsNumOfFloats = bufferRequest.totalSizeAsNumOfFloats;\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(totalSizeAsNumOfFloats), gl.STATIC_DRAW);\n    } else {\n      buffer = bufferRequest.buffer;\n      // Still need to bind buffer so that `vertexAttribPointer` points to the right buffer:\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    }\n\n    const numFloatsPerVertex = attributeRequest.numFloatsPerVertex;\n    const stride = attributeRequest.stride;\n    const offset = attributeRequest.offset;\n\n    // Need this step because a \"no buffer selected\" error will be generated if\n    // this attribute is enabled but not bound to any buffer through\n    // `bindBuffer`/`vertextAttribPointer` by the time of the first\n    // `gl.drawArrays` or `gl.drawElements` call. See\n    // https://bugs.webkit.org/show_bug.cgi?id=40315\n    gl.enableVertexAttribArray(location);\n\n    gl.vertexAttribPointer(location, numFloatsPerVertex, gl.FLOAT, false, stride, offset);\n\n    if (attributeRequest.isInstanced === true) {\n      if (input.version === WebGLVersion.One) {\n        input.instancedDrawingExtension.vertexAttribDivisorANGLE(location, 1);\n      } else if (input.version === WebGLVersion.Two) {\n        input.gl.vertexAttribDivisor(location, 1);\n      } else {\n        failIfValidOrNonExhaustive(input, 'Invalid version');\n      }\n    }\n\n    const thisAttributeInfo: IAttributeInfo = {\n      location, buffer, numFloatsPerVertex, stride, offset,\n    };\n\n    attributeInfo[attributeName] = thisAttributeInfo;\n  }\n\n  // Pre-allocate buffer space for index:\n  const indexSize = indexBuffer.totalSizeAsNumOfInts;\n  const indexElementType = indexBuffer.elementType;\n\n  let dummyDataAsBinary: Uint16Array | Uint32Array;\n  let indexElementTypeForDrawCall: number;\n  if (indexElementType === IndexElementType.Int16) {\n    dummyDataAsBinary = new Uint16Array(indexSize);\n    indexElementTypeForDrawCall = gl.UNSIGNED_SHORT;\n  } else if (indexElementType === IndexElementType.Int32) {\n    dummyDataAsBinary = new Uint32Array(indexSize);\n    indexElementTypeForDrawCall = gl.UNSIGNED_INT;\n  } else {\n    failIfValidOrNonExhaustive(indexElementType, 'Invalid index element type');\n    // Following lines will never be executed:\n    dummyDataAsBinary = undefined as any;\n    indexElementTypeForDrawCall = 0;\n  }\n  const indicesBuffer = gl.createBuffer();\n  if (indicesBuffer === null) {\n    throw new Error('Cannot create indices buffer');\n  }\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, dummyDataAsBinary, gl.STATIC_DRAW);\n  const indexBufferInfo: IIndexBufferInfo = {\n    elementType: indexElementTypeForDrawCall, buffer: indicesBuffer,\n  };\n\n  if (input.version === WebGLVersion.One) {\n    input.vaoExtension.bindVertexArrayOES(null as any);\n  } else if (input.version === WebGLVersion.Two) {\n    input.gl.bindVertexArray(null as any);\n  } else {\n    failIfValidOrNonExhaustive(input, 'Invalid version');\n  }\n\n  const uniformLocations: Record<string, WebGLUniformLocation> = {};\n  for (const uniformName of uniforms) {\n    const location = gl.getUniformLocation(program, uniformName);\n    if (location === null) {\n      throw new Error('Error getting location of uniform variable ' + uniformName + '. ' + gl.getError());\n    }\n    uniformLocations[uniformName] = location;\n  }\n\n  let result: IProgramInfo;\n  if (input.version === WebGLVersion.One) {\n    result = {\n      version: WebGLVersion.One,\n      program,\n      attributes: attributeInfo,\n      uniforms: uniformLocations,\n      indexBuffer: indexBufferInfo,\n    };\n  } else if (input.version === WebGLVersion.Two) {\n\n    const uniformBlockRequests = input.uniformBlocks;\n    const uniformBlockInfo: Record<string, IUniformBlockInfo> = {};\n    for (const {name, assignedBlockIndex, assignedBuffer} of uniformBlockRequests) {\n      // See https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object#OpenGL_Usage\n      const blockIndex = input.gl.getUniformBlockIndex(program, name);\n      input.gl.uniformBlockBinding(program, blockIndex, assignedBlockIndex);\n      input.gl.bindBuffer(input.gl.UNIFORM_BUFFER, assignedBuffer);\n      input.gl.bindBufferBase(input.gl.UNIFORM_BUFFER, assignedBlockIndex, assignedBuffer);\n      const blockInfo: IUniformBlockInfo = {\n        buffer: assignedBuffer,\n      };\n      uniformBlockInfo[name] = blockInfo;\n    }\n    result = {\n      version: WebGLVersion.Two,\n      program,\n      attributes: attributeInfo,\n      uniforms: uniformLocations,\n      indexBuffer: indexBufferInfo,\n      uniformBlocks: uniformBlockInfo,\n    };\n  } else {\n    failIfValidOrNonExhaustive(input, 'Invalid version');\n    // These lines will never be executed:\n    result = undefined as any;\n  }\n\n  return result;\n};\n\ntype IMeasureGPUTimeOptions = {\n  description: string,\n} & (\n  {\n    version: WebGLVersion.One;\n    gl: WebGLRenderingContext;\n    timerExtension: EXTDisjointTimerQuery\n  } | {\n    version: WebGLVersion.Two;\n    gl: WebGL2RenderingContext;\n    timerExtension: EXT_disjoint_timer_query_webgl2;\n  }\n);\nexport const measureGPUTime = (\n    options: IMeasureGPUTimeOptions,\n    drawFunction: () => void,\n    // This is needed because time measurement result isn't available right away:\n    reportingDelay = 1_000) => {\n\n  if (process.env.NODE_ENV === 'production') {\n    drawFunction();\n  } else {\n    if (options.timerExtension === null) {\n      console.warn('timer extension is not defined');\n      drawFunction();\n    } else {\n\n      type StoredQuery = {\n        version: WebGLVersion.One;\n        query: WebGLTimerQueryEXT;\n        timerExtension: EXTDisjointTimerQuery;\n        gl: WebGLRenderingContext;\n      } | {\n        version: WebGLVersion.Two;\n        query: WebGLQuery;\n        timerExtension: EXT_disjoint_timer_query_webgl2;\n        gl: WebGL2RenderingContext;\n      };\n\n      let storedQuery: StoredQuery;\n      if (options.version === WebGLVersion.One) {\n        const timerExtension = options.timerExtension;\n        const query =  timerExtension.createQueryEXT();\n        storedQuery = {\n          version: WebGLVersion.One,\n          query,\n          timerExtension,\n          gl: options.gl,\n        };\n        timerExtension.beginQueryEXT(timerExtension.TIME_ELAPSED_EXT, query);\n      } else {\n        const timerExtension = options.timerExtension!;\n        const gl = options.gl;\n        const query = gl.createQuery();\n        storedQuery = {\n          version: WebGLVersion.Two,\n          query,\n          timerExtension,\n          gl: options.gl,\n        };\n        gl.beginQuery(timerExtension.TIME_ELAPSED_EXT, query);\n      }\n\n      drawFunction();\n\n      const description = options.description;\n\n      if (storedQuery.version === WebGLVersion.One) {\n        const timerExtension = storedQuery.timerExtension;\n        const query = storedQuery.query;\n        const gl = storedQuery.gl;\n\n        storedQuery.timerExtension.endQueryEXT(storedQuery.timerExtension.TIME_ELAPSED_EXT);\n\n        setTimeout(() => {\n          const available = timerExtension.getQueryObjectEXT(query!, timerExtension.QUERY_RESULT_AVAILABLE_EXT);\n          const disjoint = gl.getParameter(timerExtension.GPU_DISJOINT_EXT);\n\n          if (available && !disjoint) {\n            // See how much time the rendering of the object took in nanoseconds.\n            const timeElapsed = timerExtension.getQueryObjectEXT(query!, timerExtension.QUERY_RESULT_EXT);\n\n            console.info('timeElapsed for', description, ':', timeElapsed / 1_000_000, 'ms');\n          }\n        }, reportingDelay);\n\n      } else {\n        const timerExtension = storedQuery.timerExtension;\n        const query = storedQuery.query;\n        const gl = storedQuery.gl;\n        gl.endQuery(timerExtension.TIME_ELAPSED_EXT);\n\n        setTimeout(() => {\n          const available = gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE);\n          const disjoint = gl.getParameter(timerExtension.GPU_DISJOINT_EXT);\n\n          if (available && !disjoint) {\n            const timeElapsed = gl.getQueryParameter(query, gl.QUERY_RESULT);\n            console.info('timeElapsed for', description, ':', timeElapsed / 1_000_000, 'ms');\n          }\n\n        }, reportingDelay);\n      }\n\n    }\n  }\n};\n","export interface ITreeMapCell {\n  // Key used to manage transition animations between different tree maps. No\n  // two cells across all possible different tree maps should have the same\n  // `uniqueKey`:\n  id: string;\n  // Monetary value of a cell:\n  value: number;\n\n  color: string;\n\n  x0: number;\n  y0: number;\n  x1: number;\n  y1: number;\n\n  // info about where and how cell label should be displayed:\n  textLayout: TextLayout;\n\n  // optional info on whether this cell is a comparison or not\n  comparison?: boolean;\n}\n\n// Layout for percentage numbers in each cell:\nexport type ShareLayout  = {\n  showText: false,\n} | {\n  showText: true;\n  fontSize: number;\n  text: string;\n};\n\nexport type LabelLayout = {\n  showText: false,\n} | {\n  showText: true,\n  fontSize: number;\n  useMargin: boolean;\n  // `textSplitIntoLines` are broken into separate lines for use in SVG which\n  // does not support text wrapping. `textUnsplit` is used in DOM:\n  textSplitIntoLines: string[]\n  textUnsplit: string;\n};\n// (for smaller cells) 3) no label at all (cells that are too small).\nexport enum TextLayoutType {\n  ShowBoth = 'ShowBoth',\n  ShowOnlyShare = 'ShowOnlyShare',\n  ShowNone = 'ShowNone',\n}\n// 3 types of tree map cell labels. If there's enough space, we show both the\n// label and percentage. If there's not enough space for a label for enough for\n// a percentage, we show only the percentage. Otherwise, show nothing:\nexport type TextLayout = {\n  type: TextLayoutType.ShowBoth;\n  label: LabelLayout;\n  share: ShareLayout;\n} | {\n  type: TextLayoutType.ShowOnlyShare;\n  share: ShareLayout;\n} | {\n  type: TextLayoutType.ShowNone,\n};\n","import {\n  measuredCharacterHeight,\n  referenceFontSize,\n} from './Utils';\n\ninterface IWithExportImport {\n  value: number | null;\n}\n\ntype ComputedDatum<T extends IWithExportImport> = Omit<T, 'value'> & {monetaryValue: number};\n\nexport const computeGrossNetTradeValues = <T extends IWithExportImport>(\n    input: T[]\n  ): Array<ComputedDatum<T>> => {\n\n  let result: Array<ComputedDatum<T>> = input.map(\n    ({value, ...rest}) => {\n      const monetaryValue = value ? value : 0;\n      return {monetaryValue, ...rest};\n    },\n  );\n  return result;\n};\n\ninterface IWithMonetaryValue {\n  monetaryValue: number;\n}\nexport const filterByMonetaryValues =\n  <T extends IWithMonetaryValue>(data: T[]): T[] =>\n    data.filter(({monetaryValue}) => monetaryValue > 0);\n\n//#region Constants\n// The font size should never get smaller than this:\nexport const minNodeNameFontSize = 8;\nexport const labelHorizontalMargin = 0.05; // in percentage points i.e. the number '5' means '5%'\nexport const labelTopMargin = 0.05; // in percentage points\nexport const heightProportionReservedForShare = 0.2; // in percentage points\n\nexport const maxCharacterHeightAtMinFontSize = measuredCharacterHeight / referenceFontSize * minNodeNameFontSize;\n//#endregion\n","import color from 'color';\nimport intervalTreeDefaultExport, {\n  Interval,\n  IntervalTree,\n} from 'interval-tree-1d';\nimport {\n  desaturate,\n} from 'polished';\nimport {\n  ColorQuadruplet,\n  ColorTriplet,\n  IUpdatePatternItem,\n  normalizeColorTriplet,\n  PersistentFloat32Array,\n  UpdateType,\n} from './webglUtils';\nimport {\n  failIfValidOrNonExhaustive,\n} from './Utils';\nimport {\n  ITreeMapCell,\n  TextLayout,\n} from './otherTypes';\n\nexport enum NumCellsTier {\n  // Use `Small` for all type of tree maps except for product tree maps at\n  // 6-digit detail level:\n  Small,\n  Large,\n}\n\nexport const transitionDuration = 350; // in ms;\n\nexport interface ICellInternal {\n  id: string;\n  fillColor: ColorQuadruplet;\n  strokeOpacity: number;\n  x0: number;\n  y0: number;\n  x1: number;\n  y1: number;\n  textLayout: TextLayout;\n  isComparisonCell: boolean;\n}\n\nconst getColorTripletFromColorString =\n  (colorString: string) => normalizeColorTriplet(color(colorString).rgb().array() as ColorTriplet);\n\nexport const convertToInternalCells =\n  (cellList: ITreeMapCell[], highlighted: string | undefined) => {\n\n  const nextCells: Map<string, ICellInternal> = new Map();\n  const nextKeys: string[] = [];\n\n  const cellListLength = cellList.length;\n  const someCellHighlighted = (highlighted !== undefined);\n  for (let i = 0; i < cellListLength; i += 1) {\n    const cell = cellList[i];\n    const id = cell.id;\n    const x0 = cell.x0;\n    const y0 = cell.y0;\n    const x1 = cell.x1;\n    const y1 = cell.y1;\n    const isComparisonCell = cell.comparison ? true : false;\n    const textLayout = cell.textLayout;\n    const retrievedColor = cell.color;\n\n    const colorTriplet: ColorTriplet = (someCellHighlighted && highlighted !== id) ?\n                                        getColorTripletFromColorString(desaturate(0.3, retrievedColor)) :\n                                        getColorTripletFromColorString(retrievedColor);\n    const colorQuadruplet = [colorTriplet[0], colorTriplet[1], colorTriplet[2], 1] as ColorQuadruplet;\n    const internalCell: ICellInternal = {\n      id, x0, y0, x1, y1, textLayout,\n      fillColor: colorQuadruplet,\n      strokeOpacity: 1,\n      isComparisonCell,\n    };\n    nextKeys.push(id);\n    nextCells.set(id, internalCell);\n  }\n  return {\n    nextCells, nextKeys,\n  };\n};\n\nexport const rectangleReferencePositionValues = [\n  // top left:\n  1, 1,\n  // top right:\n  0, 1,\n  // bottom right:\n  0, 0,\n  // bottom left:\n  1, 0,\n];\n\nexport const rectangleIndices = [\n  1, 0, 2,\n  2, 0, 3,\n];\nexport const rectangleIndicesCount = rectangleIndices.length;\n\nexport const numFloatsPerCellInstance = 17;\n\nexport const writeToCellBuffers = (\n    prevCells: Map<string, ICellInternal>,\n    nextCells: Map<string, ICellInternal>,\n    updatePattern: IUpdatePatternItem[],\n    halfStrokeWidth: number,\n    strokeColor: ColorQuadruplet,\n    cellBuffer: PersistentFloat32Array,\n  ) => {\n\n  const updatePatternLength = updatePattern.length;\n\n  const numInstancesPerCell = 2;\n  const actualBuffer = cellBuffer.buffer;\n  const numFloatsPerCell = numFloatsPerCellInstance * numInstancesPerCell;\n  cellBuffer.length = updatePatternLength * numFloatsPerCell;\n\n  for (let i = 0; i < updatePatternLength; i += 1) {\n    const {key, type} = updatePattern[i];\n    let initialTopLeftX: number, initialTopLeftY: number;\n    let finalTopLeftX: number, finalTopLeftY: number;\n    let initialBottomRightX: number, initialBottomRightY: number;\n    let finalBottomRightX: number, finalBottomRightY: number;\n    let initialFillColor: ColorQuadruplet, finalFillColor: ColorQuadruplet;\n    let initialStrokeColor: ColorQuadruplet, finalStrokeColor: ColorQuadruplet;\n    let strokeWidth: number;\n\n    if (type === UpdateType.Enter) {\n      const cell = nextCells.get(key)!;\n      initialTopLeftX = finalTopLeftX = cell.x0;\n      initialTopLeftY = finalTopLeftY = cell.y0;\n      initialBottomRightX = finalBottomRightX = cell.x1;\n      initialBottomRightY = finalBottomRightY = cell.y1;\n\n      const {fillColor, isComparisonCell} = cell;\n      initialFillColor = fillColor.slice(0) as ColorQuadruplet;\n      initialFillColor[3] = 0;\n      finalFillColor = fillColor.slice(0) as ColorQuadruplet;\n\n      initialStrokeColor = strokeColor.slice(0) as ColorQuadruplet;\n      initialStrokeColor[3] = 0;\n      finalStrokeColor = strokeColor.slice(0) as ColorQuadruplet;\n      strokeWidth = isComparisonCell ? 0 : halfStrokeWidth;\n\n    } else if (type === UpdateType.Exit) {\n      const cell = prevCells.get(key)!;\n      initialTopLeftX = finalTopLeftX = cell.x0;\n      initialTopLeftY = finalTopLeftY = cell.y0;\n      initialBottomRightX = finalBottomRightX = cell.x1;\n      initialBottomRightY = finalBottomRightY = cell.y1;\n\n      const {fillColor, strokeOpacity, isComparisonCell} = cell;\n\n      initialFillColor = fillColor.slice(0) as ColorQuadruplet;\n      finalFillColor = fillColor.slice(0) as ColorQuadruplet;\n      finalFillColor[3] = 0;\n\n      initialStrokeColor = strokeColor.slice(0) as ColorQuadruplet;\n      initialStrokeColor[3] = strokeOpacity;\n      finalStrokeColor = strokeColor.slice(0) as ColorQuadruplet;\n      finalStrokeColor[3] = 0;\n      strokeWidth = isComparisonCell ? 0 : halfStrokeWidth;\n\n    } else if (type === UpdateType.Update) {\n      const prevCell = prevCells.get(key)!;\n      const nextCell = nextCells.get(key)!;\n      ({\n        x0: initialTopLeftX, y0: initialTopLeftY, x1: initialBottomRightX, y1: initialBottomRightY,\n        /* tslint:disable-next-line:trailing-comma */\n        fillColor: initialFillColor\n      } = prevCell);\n      ({\n        x0: finalTopLeftX, y0: finalTopLeftY, x1: finalBottomRightX, y1: finalBottomRightY,\n        /* tslint:disable-next-line:trailing-comma */\n        fillColor: finalFillColor\n      } = nextCell);\n\n      initialStrokeColor = strokeColor.slice(0) as ColorQuadruplet;\n      initialStrokeColor[3] = prevCell.strokeOpacity;\n\n      finalStrokeColor = strokeColor.slice(0) as ColorQuadruplet;\n      finalStrokeColor[3] = nextCell.strokeOpacity;\n      strokeWidth = halfStrokeWidth;\n\n    } else {\n      failIfValidOrNonExhaustive(type, 'Invalid update type');\n      // These lines will never execute:\n      initialTopLeftX = finalTopLeftX = 0;\n      initialTopLeftY = finalTopLeftY = 0;\n      initialBottomRightX = finalBottomRightX = 0;\n      initialBottomRightY = finalBottomRightY = 0;\n      initialFillColor = finalFillColor = [0, 0, 0, 0];\n      initialStrokeColor = finalStrokeColor = [0, 0, 0, 0];\n      strokeWidth = halfStrokeWidth;\n    }\n\n    // Add the position values twice because they are shared by the fill and stroke rectangles:\n    for (let j = 0; j < numFloatsPerCellInstance; j += 1) {\n      // initialTopLeft\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j] = initialTopLeftX;\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j + 1] = initialTopLeftY;\n\n      // finalTopLeft\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j + 2] = finalTopLeftX;\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j + 3] = finalTopLeftY;\n\n      // initialBottomRight:\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j + 4] = initialBottomRightX;\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j + 5] = initialBottomRightY;\n\n      // finalBottomRight:\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j + 6] = finalBottomRightX;\n      actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance * j + 7] = finalBottomRightY;\n    }\n\n    let numFloatsSetPerInstanceSoFar = 8;\n\n    // Assign stroke color to first instance:\n    for (let k = 0; k < 4; k += 1) {\n      actualBuffer[numFloatsPerCell * i + numFloatsSetPerInstanceSoFar + k] = initialStrokeColor[k];\n      actualBuffer[numFloatsPerCell * i + numFloatsSetPerInstanceSoFar + 4 + k] = finalStrokeColor[k];\n    }\n\n    // Assign fill color to second instance:\n    for (let m = 0; m < 4; m += 1) {\n      actualBuffer[\n        numFloatsPerCell * i + numFloatsPerCellInstance + numFloatsSetPerInstanceSoFar + m\n      ] = initialFillColor[m];\n      actualBuffer[\n        numFloatsPerCell * i + numFloatsPerCellInstance + numFloatsSetPerInstanceSoFar + 4 + m\n      ] = finalFillColor[m];\n    }\n\n    numFloatsSetPerInstanceSoFar = 16;\n    // Set `halfStrokeWidth` to 0 for first instance (stroke):\n    actualBuffer[numFloatsPerCell * i + numFloatsSetPerInstanceSoFar] = 0;\n    // Set `halfStrokeWidth` to `halfStrokeWidth` for first instance (fill):\n    actualBuffer[numFloatsPerCell * i + numFloatsPerCellInstance + numFloatsSetPerInstanceSoFar] = strokeWidth;\n  }\n\n  return {\n    instancesCount: updatePatternLength * 2,\n  };\n};\n\nexport const getIntervalTrees = (\n    nextKeys: string[],\n    nextCells: Map<string, ICellInternal>,\n    // Need to do this because doing this\n    // `import createIntervalTree from 'interval-tree-1d`\n    // works in TypeScript but not in jest so we need to import the module separately\n    // in the typescript and jest worlds.\n    // TODO: figure out why there's discrepancy between how jest and typescript produces\n    // different import calls\n    createIntervalTree: typeof intervalTreeDefaultExport,\n  ) => {\n\n  const nextKeysLength = nextKeys.length;\n  const xIntervals: Array<Interval<string>> = [];\n  const yIntervals: Array<Interval<string>> = [];\n  for (let i = 0; i < nextKeysLength; i += 1) {\n    const cell = nextCells.get(nextKeys[i])!;\n    const id = cell.id;\n    const x0 = cell.x0;\n    const y0 = cell.y0;\n    const x1 = cell.x1;\n    const y1 = cell.y1;\n\n    const xInterval: Interval<string> = [x0, x1, id];\n    const yInterval: Interval<string> = [y0, y1, id];\n    xIntervals.push(xInterval);\n    yIntervals.push(yInterval);\n  }\n\n  return {\n    xIntervalTree: createIntervalTree(xIntervals),\n    yIntervalTree: createIntervalTree(yIntervals),\n  };\n};\n\nexport const searchForHits = (\n    xIntervalTree: IntervalTree<string>,\n    yIntervalTree: IntervalTree<string>,\n    xMax: number,\n    yMax: number,\n    xTarget: number,\n    yTarget: number,\n  ) => {\n\n  if (xTarget < 0 || xTarget > xMax || yTarget < 0 || yTarget > yMax) {\n    return undefined;\n  }  else {\n    const xMatchIds: string[] = [];\n    xIntervalTree.queryPoint(xTarget, (interval: Interval<string>) => {\n      xMatchIds.push(interval[2]);\n      return undefined;\n    });\n\n    const yMatchIds: string[] = [];\n    yIntervalTree.queryPoint(yTarget, (interval: Interval<string>) => {\n      yMatchIds.push(interval[2]);\n      return undefined;\n    });\n\n    const numXMatches = xMatchIds.length;\n    const numYMatches = yMatchIds.length;\n\n    for (let i = 0; i < numXMatches; i += 1) {\n      const xId = xMatchIds[i];\n      for (let j = 0; j < numYMatches; j += 1) {\n        const yId = yMatchIds[j];\n        if (xId === yId) {\n          return xId;\n        }\n      }\n    }\n    return undefined;\n  }\n};\n","import Pool from './DOMPool';\nimport {\n  IUpdatePatternItem,\n  UpdateType,\n} from './webglUtils';\nimport {\n  ICellInternal,\n} from './domIndependentDrawUtils';\nimport {\n  TextLayoutType,\n} from './otherTypes';\nimport {\n  heightProportionReservedForShare,\n  labelHorizontalMargin,\n  labelTopMargin,\n} from './transformUtils';\n\ninterface ITextElemStyles {\n  className: string;\n  textContent: string;\n  top: string;\n  left: string;\n  width: string;\n  height: string;\n  fontSize: string;\n  paddingTop: string;\n  paddingLeft: string;\n  paddingRight: string;\n}\n\nconst applyStyleToDOMNode = (domNode: HTMLElement, textStyle: ITextElemStyles) => {\n  domNode.className = textStyle.className;\n  domNode.textContent = textStyle.textContent;\n  domNode.style.top = textStyle.top;\n  domNode.style.left = textStyle.left;\n  domNode.style.width = textStyle.width;\n  domNode.style.height = textStyle.height;\n  domNode.style.fontSize = textStyle.fontSize;\n  domNode.style.paddingTop = textStyle.paddingTop;\n  domNode.style.paddingLeft = textStyle.paddingLeft;\n  domNode.style.paddingRight = textStyle.paddingRight;\n};\n\nexport const getTextLabelFragment = (\n    nextCells: Map<string, ICellInternal>,\n    updatePattern: IUpdatePatternItem[],\n    allCurrentlyAttachedDOMNodes: HTMLElement[],\n    pool: Pool,\n  ) => {\n\n  const childrenNodes: HTMLElement[] = [];\n  const updatePatternLength = updatePattern.length;\n  for (let i = 0; i < updatePatternLength; i += 1) {\n    const {key, type} = updatePattern[i];\n    if (type === UpdateType.Enter || type === UpdateType.Update) {\n      const {textLayout, x0, y0, x1, y1} = nextCells.get(key)!;\n      const cellWidth = x1 - x0;\n      const cellHeight = y1 - y0;\n      const generalClassName = 'react-canvas-tree-map-container';\n      const percentageClassName = 'react-canvas-tree-map-container react-canvas-tree-map-percentage';\n      if (textLayout.type === TextLayoutType.ShowBoth) {\n        const {label, share} = textLayout;\n\n        const heightAvailableForLabel = cellHeight * (1 - heightProportionReservedForShare);\n\n        if (label.showText === true) {\n          let paddingTop: string, horizontalPadding: string;\n          if (label.useMargin === true) {\n            paddingTop = `${labelTopMargin * cellHeight}px`;\n            horizontalPadding = `${labelHorizontalMargin * cellWidth}px`;\n          } else {\n            paddingTop = '0';\n            horizontalPadding = '0';\n          }\n\n          const labelElem = pool.dequeue();\n          applyStyleToDOMNode(labelElem, {\n            className: generalClassName,\n            textContent: label.textUnsplit,\n            top: `${y0}px`,\n            left: `${x0}px`,\n            width: `${cellWidth}px`,\n            height: `${heightAvailableForLabel}px`,\n            fontSize: `${label.fontSize}px`,\n            paddingTop,\n            paddingLeft: horizontalPadding,\n            paddingRight: horizontalPadding,\n          });\n          childrenNodes.push(labelElem);\n        }\n\n        if (share.showText === true) {\n          const heightAvailableForPercentage = cellHeight * heightProportionReservedForShare;\n          const top = y0 + heightAvailableForLabel;\n\n          const shareElem = pool.dequeue();\n          applyStyleToDOMNode(shareElem, {\n            className: percentageClassName,\n            textContent: share.text,\n            top: `${top}px`,\n            left: `${x0}px`,\n            width: `${cellWidth}px`,\n            height: `${heightAvailableForPercentage}px`,\n            fontSize: `${share.fontSize}px`,\n            paddingTop: '',\n            paddingLeft: '',\n            paddingRight: '',\n          });\n          childrenNodes.push(shareElem);\n        }\n      } else if (textLayout.type === TextLayoutType.ShowOnlyShare) {\n        const {share} = textLayout;\n        if (share.showText === true) {\n\n          const shareElem = pool.dequeue();\n          applyStyleToDOMNode(shareElem, {\n            className: percentageClassName,\n            textContent: share.text,\n            top: `${y0}px`,\n            left: `${x0}px`,\n            width: `${cellWidth}px`,\n            height: `${cellHeight}px`,\n            fontSize: `${share.fontSize}px`,\n            paddingTop: '',\n            paddingLeft: '',\n            paddingRight: '',\n          });\n          childrenNodes.push(shareElem);\n        }\n      }\n    }\n  }\n  const fragment = document.createDocumentFragment();\n  const rootNode = document.createElement('div');\n  rootNode.className = 'react-canvas-tree-map-masterContainer';\n\n  const childrenNodesLength = childrenNodes.length;\n  for (let j = 0; j < childrenNodesLength; j += 1) {\n    rootNode.appendChild(childrenNodes[j]);\n  }\n\n  fragment.appendChild(rootNode);\n\n  allCurrentlyAttachedDOMNodes = allCurrentlyAttachedDOMNodes.concat(childrenNodes);\n\n  return {\n    fragment, rootNode, allCurrentlyAttachedDOMNodes,\n  };\n};\n","import {\n  useEffect,\n  useRef,\n} from 'react';\n\n// This ref always tracks the value of `value`:\nexport default <T>(value: T) => {\n  const ref = useRef<T>(value);\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref;\n};\n","import {CSSPlugin, TimelineLite, TweenLite} from 'gsap';\nimport createIntervalTree, {\n  IntervalTree,\n} from 'interval-tree-1d';\nimport once from 'lodash/once';\nimport throttle from 'lodash/throttle';\nimport React, {\n  MutableRefObject,\n  useEffect,\n  useRef,\n} from 'react';\nimport styled from 'styled-components/macro';\nimport DOMPool from './DOMPool';\nimport {\n  ANGLEInstancedArrays,\n  AttributeBufferRequestType,\n  createPopulatedGLBuffer,\n  EXTDisjointTimerQuery,\n  getProgramInfo,\n  getUpdatePattern,\n  GL_NUM_BYTES_PER_FLOAT,\n  IndexElementType,\n  IProgramInfo,\n  normalizeColorQuadruplet,\n  PersistentFloat32Array,\n  resizeViewport,\n  sendAttributesToGPUWithVAO,\n  sendIndicesToGPUWithVAO,\n  updateGLBuffer,\n  WebGLVersion,\n} from './webglUtils';\nimport {\n  failIfValidOrNonExhaustive,\n  millisecondsPerSeconds,\n  halfStrokeWidth as defaultStrokeWidth,\n  strokeColor,\n} from './Utils';\nimport {\n  getTextLabelFragment,\n} from './domDependentDrawUtils';\nimport {\n  convertToInternalCells,\n  getIntervalTrees,\n  ICellInternal,\n  NumCellsTier,\n  numFloatsPerCellInstance,\n  rectangleIndices,\n  rectangleIndicesCount,\n  rectangleReferencePositionValues,\n  searchForHits,\n  transitionDuration,\n  writeToCellBuffers,\n} from './domIndependentDrawUtils';\n\nimport {\n  ITreeMapCell,\n} from './otherTypes';\nimport usePropsChangeRateLimiter, {\n  PropsChangeHandlerInput,\n} from './usePropsChangeRateLimiter';\nimport useTrackingRef from './useTrackingRef';\nimport raw from 'raw.macro';\n\n// Need to do this so that `CSSPlugin` is not dropped by the minifier:\nif (!CSSPlugin) {\n  console.error('CSSPlugin failed to load', CSSPlugin);\n}\n\n//#region Styling\nconst Root = styled.div`\n  contain: content;\n  .react-canvas-tree-map-container {\n    position: absolute;\n    color: white;\n    font-weight: 300;\n    box-sizing: border-box;\n  }\n\n  .react-canvas-tree-map-percentage {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n\n  .react-canvas-tree-map-masterContainer {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    opacity: 0;\n    will-change: opacity;\n    -webkit-transition: opacity 175ms ease-out;\n    transition: opacity 175ms ease-out;\n  }\n\n`;\n//#endregion\n\nconst normalizedStrokeColor = normalizeColorQuadruplet(strokeColor);\n\nconst durationInSeconds = transitionDuration / millisecondsPerSeconds;\nconst hoverContinuousHitTestFrameRate = 20;\n\n// This the max number of cells that can possibly appear for all tree maps\n// except the 6-digit product tree map. This is the sum of (the number of\n// 4-digit HS products) + (the number of 4-digit SITC products):\nconst maxNumCellsAtAnyTimeLowTier = 2600;\n// This the max number of cells that can possibly happen when 6 digit is enabled\n// which we call here \"higher tier\".\n// This is the sum of the (number of 6-digit HS products) + max of (number of\n// 4-digit HS products, number of SITC 4-digit products):\nconst maxNumCellsAtAnyTimeHighTier = 8000;\n// for each cell, we draw 2 rectangles: one for stroke and one for fill:\nconst numInstancesPerCell = 2;\n\nenum AnimationStatus {\n  Initial,\n  InProgress,\n  FinishedCompletely,\n}\n\ntype TextContainerTransitionStatus = {\n  isTextContainerChanging: true\n  prevContainer: HTMLElement;\n  prevAttachedDOMNodes: HTMLElement[];\n  nextContainer: HTMLElement;\n  nextAttachedDOMNodes: HTMLElement[];\n  fragment: DocumentFragment;\n} | {\n  isTextContainerChanging: false;\n  currentTextContainer: HTMLElement;\n  currentAttachedDOMNodes: HTMLElement[];\n};\n\ntype Status = {\n  status: AnimationStatus.Initial,\n} | {\n  status: AnimationStatus.InProgress,\n  timeline: gsap.Timeline;\n} | {\n  status: AnimationStatus.FinishedCompletely,\n  // Cell related:\n  currentCells: Map<string, ICellInternal>;\n  currentKeys: string[];\n  cellIndicesCount: number;\n  cellInstancesCount: number;\n\n  // Hit test related\n  xIntervalTree: IntervalTree<string>;\n  yIntervalTree: IntervalTree<string>;\n  // Text related:\n  currentTextContainer: HTMLElement;\n  currentAttachedDOMNodes: HTMLElement[];\n};\n\ninterface IGLInfo {\n  gl: WebGLRenderingContext;\n  vaoExtension: OES_vertex_array_object;\n  timerExtension: EXTDisjointTimerQuery | null;\n  instancedDrawingExtension: ANGLEInstancedArrays;\n  cellsVAO: WebGLVertexArrayObjectOES;\n  cellBuffer: PersistentFloat32Array;\n  cellGLBuffer: WebGLBuffer;\n  rebindGLBuffer: (buffer: PersistentFloat32Array) => void;\n}\n\nconst createCellsBuffer = (numCellsTier: NumCellsTier): PersistentFloat32Array => {\n  let numCells: number;\n  if (numCellsTier === NumCellsTier.Small) {\n    numCells = maxNumCellsAtAnyTimeLowTier;\n  } else if (numCellsTier === NumCellsTier.Large) {\n    numCells = maxNumCellsAtAnyTimeHighTier;\n  } else {\n    failIfValidOrNonExhaustive(numCellsTier, 'Invalid num cells tier' + numCellsTier);\n    // The following lines will never execute:\n    numCells = 0;\n  }\n  return new PersistentFloat32Array(\n    numCells * numInstancesPerCell * numFloatsPerCellInstance,\n  );\n};\n\n// Assume that the cells are not the same if either the identities of the cells are different\n// or the sizes or colors are different:\nconst haveCellsChanged = (prevCells: ITreeMapCell[], nextCells: ITreeMapCell[]): boolean => {\n  const prevCellsLength = prevCells.length;\n  const nextCellsLength = nextCells.length;\n  if (prevCellsLength !== nextCellsLength) {\n    return true;\n  } else {\n    for (let i = 0; i < prevCellsLength; i += 1) {\n      const prevCell = prevCells[i];\n      const nextCell = nextCells[i];\n      if (prevCell.value !== nextCell.value ||\n            prevCell.id !== nextCell.id ||\n            prevCell.color !== nextCell.color) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\nconst setupWebGL = (input: {\n    numCellsTier: NumCellsTier\n    canvasRef: MutableRefObject<HTMLCanvasElement | null>\n    glInfoRef: MutableRefObject<IGLInfo | undefined>\n    cellProgramRef: MutableRefObject<IProgramInfo | undefined>,\n  }) => {\n\n  const {\n    numCellsTier,\n    canvasRef: {current: canvas},\n    glInfoRef, cellProgramRef,\n  } = input;\n  if (canvas !== null) {\n    const gl = canvas.getContext('webgl', {alpha: false});\n    if (gl === null) {\n      console.warn('WebGL not available');\n      glInfoRef.current = undefined;\n    } else {\n      const vaoExtension = gl.getExtension('OES_vertex_array_object');\n      const instancedDrawingExtension = gl.getExtension('ANGLE_instanced_arrays');\n\n      const cellBuffer = createCellsBuffer(numCellsTier);\n\n      let timerExtension: EXTDisjointTimerQuery | null = null;\n      if (process.env.NODE_ENV !== 'production') {\n        timerExtension = gl.getExtension('EXT_disjoint_timer_query');\n      }\n\n      if (vaoExtension === null || instancedDrawingExtension === null) {\n        if (vaoExtension === null) {\n          console.warn('OES_vertex_array_object extension not available.');\n        }\n        if (instancedDrawingExtension === null) {\n          console.warn('ANGLE_instanced_arrays extension not available');\n        }\n        glInfoRef.current = undefined;\n      } else {\n        const cellsVAO = vaoExtension.createVertexArrayOES();\n\n        if (cellsVAO === null) {\n          throw new Error('Cannot create vertex array for cells');\n        }\n\n        const {\n          buffer: cellGLBuffer,\n          rebindBuffer: rebindGLBuffer,\n        } = createPopulatedGLBuffer(gl, cellBuffer);\n\n        cellProgramRef.current = getProgramInfo({\n          version: WebGLVersion.One,\n          gl,\n          vertexShader: raw('./rectangle.vert'),\n          fragmentShader: raw('./rectangle.frag'),\n          attributes: [{\n            name: 'referencePosition',\n            numFloatsPerVertex: 2,\n            buffer: {\n              type: AttributeBufferRequestType.Implicit,\n              totalSizeAsNumOfFloats: rectangleReferencePositionValues.length,\n            },\n            stride: 0,\n            offset: 0,\n            isInstanced: false,\n          }, {\n            name: 'initialTopLeft',\n            numFloatsPerVertex: 2,\n            buffer: {type: AttributeBufferRequestType.Explicit, buffer: cellGLBuffer},\n            stride: numFloatsPerCellInstance * GL_NUM_BYTES_PER_FLOAT,\n            offset: 0,\n            isInstanced: true,\n          }, {\n            name: 'finalTopLeft',\n            numFloatsPerVertex: 2,\n            buffer: {type: AttributeBufferRequestType.Explicit, buffer: cellGLBuffer},\n            stride: numFloatsPerCellInstance * GL_NUM_BYTES_PER_FLOAT,\n            offset: 2 * GL_NUM_BYTES_PER_FLOAT,\n            isInstanced: true,\n          }, {\n            name: 'initialBottomRight',\n            numFloatsPerVertex: 2,\n            buffer: {type: AttributeBufferRequestType.Explicit, buffer: cellGLBuffer},\n            stride: numFloatsPerCellInstance * GL_NUM_BYTES_PER_FLOAT,\n            offset: 4 * GL_NUM_BYTES_PER_FLOAT,\n            isInstanced: true,\n          }, {\n            name: 'finalBottomRight',\n            numFloatsPerVertex: 2,\n            buffer: {type: AttributeBufferRequestType.Explicit, buffer: cellGLBuffer},\n            stride: numFloatsPerCellInstance * GL_NUM_BYTES_PER_FLOAT,\n            offset: 6 * GL_NUM_BYTES_PER_FLOAT,\n            isInstanced: true,\n          }, {\n            name: 'initialColor',\n            numFloatsPerVertex: 4,\n            buffer: {type: AttributeBufferRequestType.Explicit, buffer: cellGLBuffer},\n            stride: numFloatsPerCellInstance * GL_NUM_BYTES_PER_FLOAT,\n            offset: 8 * GL_NUM_BYTES_PER_FLOAT,\n            isInstanced: true,\n          }, {\n            name: 'finalColor',\n            numFloatsPerVertex: 4,\n            buffer: {type: AttributeBufferRequestType.Explicit, buffer: cellGLBuffer},\n            stride: numFloatsPerCellInstance * GL_NUM_BYTES_PER_FLOAT,\n            offset: 12 * GL_NUM_BYTES_PER_FLOAT,\n            isInstanced: true,\n          }, {\n            name: 'halfStrokeWidth',\n            numFloatsPerVertex: 1,\n            buffer: {type: AttributeBufferRequestType.Explicit, buffer: cellGLBuffer},\n            stride: numFloatsPerCellInstance * GL_NUM_BYTES_PER_FLOAT,\n            offset: 16 * GL_NUM_BYTES_PER_FLOAT,\n            isInstanced: true,\n          }],\n          uniforms: ['canvasSize', 'tweenProgress'],\n          indexBuffer: {elementType: IndexElementType.Int16, totalSizeAsNumOfInts: rectangleIndicesCount},\n          vaoObject: cellsVAO,\n          vaoExtension,\n          instancedDrawingExtension,\n        });\n\n        glInfoRef.current = {\n          gl, vaoExtension, timerExtension, instancedDrawingExtension, cellsVAO,\n          cellBuffer, cellGLBuffer, rebindGLBuffer,\n        };\n      }\n    }\n  }\n};\n\nconst setWidthHeightInCSSPixels = (input: {\n    canvasRef: MutableRefObject<HTMLCanvasElement | null>,\n    widthInCSSPixelsRef: MutableRefObject<number | undefined>,\n    heightInCSSPixelsRef: MutableRefObject<number | undefined>,\n  }) => {\n\n  const {\n    canvasRef: {current: canvas},\n    widthInCSSPixelsRef, heightInCSSPixelsRef,\n  } = input;\n\n  if (canvas !== null) {\n    const {width, height} = canvas.getBoundingClientRect();\n    widthInCSSPixelsRef.current = width;\n    heightInCSSPixelsRef.current = height;\n  }\n};\n\nconst upgradeToLargeBuffer = (glInfo: IGLInfo) => {\n  const newCellBuffer = createCellsBuffer(NumCellsTier.Large);\n  newCellBuffer.copyFrom(glInfo.cellBuffer);\n  glInfo.cellBuffer = newCellBuffer;\n  glInfo.rebindGLBuffer(newCellBuffer);\n};\n\ntype IMonitoredProps = Pick<\n  IProps,\n  'cells' | 'highlighted' | 'numCellsTier' | 'chartContainerHeight' | 'chartContainerWidth' | 'comparisonTreeMap'\n>;\n\ninterface IPropsChangeHandlerExtraInputs {\n  rootElRef: MutableRefObject<HTMLDivElement | null>;\n  glInfoRef: MutableRefObject<IGLInfo | undefined>;\n  cellProgramRef: MutableRefObject<IProgramInfo | undefined>;\n  statusRef: MutableRefObject<Status>;\n  domPoolRef: MutableRefObject<DOMPool>;\n  upgradeToLargeBufferRef: MutableRefObject<typeof upgradeToLargeBuffer>;\n}\n\nconst performPropsChange =\n  (input: PropsChangeHandlerInput<IPropsChangeHandlerExtraInputs, IMonitoredProps>) => {\n\n  const {\n    nextValue,\n    extraInputs: {\n      rootElRef: {current: rootEl},\n      glInfoRef: {current: glInfo},\n      cellProgramRef: {current: cellProgram},\n      statusRef: {current: prevStatus}, statusRef,\n      domPoolRef,\n      upgradeToLargeBufferRef: {current: upgradeBuffer},\n    },\n    done,\n  } = input;\n  const halfStrokeWidth = nextValue.comparisonTreeMap ? 0 : defaultStrokeWidth;\n  const prevValue = (input.prevValue === undefined) ? nextValue : input.prevValue;\n  const hasChartSizeChanged =\n    (nextValue.chartContainerHeight !== prevValue.chartContainerHeight ||\n    nextValue.chartContainerWidth !== prevValue.chartContainerWidth) &&\n    (nextValue.chartContainerHeight !== undefined && nextValue.chartContainerWidth !== undefined);\n\n  if (hasChartSizeChanged && glInfo !== undefined) {\n    const {gl} = glInfo;\n    resizeViewport(gl, true);\n  }\n\n  if (glInfo !== undefined && cellProgram !== undefined && rootEl !== null) {\n\n    if (hasChartSizeChanged === true ||\n        // This is true on the very first render:\n        (input.prevValue === undefined) ||\n        // This is true when the data changes on subsequent renders:\n        (input.prevValue !== undefined &&\n          (haveCellsChanged(prevValue.cells, nextValue.cells)) ||\n            prevValue.highlighted !== nextValue.highlighted)\n      ) {\n\n      if (nextValue.numCellsTier !== prevValue.numCellsTier &&\n            prevValue.numCellsTier === NumCellsTier.Small &&\n            nextValue.numCellsTier === NumCellsTier.Large) {\n\n        upgradeBuffer(glInfo);\n      }\n\n      const {\n        gl, vaoExtension,\n        instancedDrawingExtension,\n        cellsVAO,\n        cellBuffer, cellGLBuffer,\n      } = glInfo;\n      if (prevStatus.status === AnimationStatus.FinishedCompletely ||\n          prevStatus.status === AnimationStatus.Initial) {\n\n        let prevCells: Map<string, ICellInternal>, prevKeys: string[];\n        let prevTextContainer: HTMLElement, prevAttachedDOMNodes: HTMLElement[];\n        if (prevStatus.status === AnimationStatus.FinishedCompletely) {\n          prevCells = prevStatus.currentCells;\n          prevKeys = prevStatus.currentKeys;\n          prevTextContainer = prevStatus.currentTextContainer;\n          prevAttachedDOMNodes = prevStatus.currentAttachedDOMNodes;\n        } else if (prevStatus.status === AnimationStatus.Initial) {\n          prevCells = new Map();\n          prevKeys = [];\n          prevTextContainer = document.createElement('div');\n          prevAttachedDOMNodes = [];\n\n          // Bind non-instanced attributes and indices for the 2 vertex shaders.\n          // This only needs to happen once because they never change:\n          vaoExtension.bindVertexArrayOES(cellsVAO);\n          sendAttributesToGPUWithVAO({\n            gl, programInfo: cellProgram,\n            attributeName: 'referencePosition',\n            data: new Float32Array(rectangleReferencePositionValues),\n          });\n          sendIndicesToGPUWithVAO({\n            gl, programInfo: cellProgram, data: new Uint16Array(rectangleIndices),\n          });\n\n          vaoExtension.bindVertexArrayOES(null);\n\n          gl.disable(gl.DEPTH_TEST);\n          gl.enable(gl.BLEND);\n          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n          gl.clearColor(1, 1, 1, 1);\n        } else {\n          failIfValidOrNonExhaustive(prevStatus, 'Invalid status type');\n          // These lines will never be executed:\n          prevCells = new Map();\n          prevKeys = [];\n          prevTextContainer = undefined as any;\n          prevAttachedDOMNodes = [];\n        }\n\n        const {cells, highlighted} = nextValue;\n        const {nextKeys, nextCells} = convertToInternalCells(cells, highlighted);\n        const updatePattern = getUpdatePattern(prevKeys, nextKeys);\n        const cellsInfo = writeToCellBuffers(\n          prevCells, nextCells, updatePattern, halfStrokeWidth, normalizedStrokeColor, cellBuffer,\n        );\n        // Update vertex data for cells:\n        updateGLBuffer({gl, buffer: cellGLBuffer, data: cellBuffer.getMeaningfulData()});\n\n        // `false` means the next update actually has no data to show so we should skip the animation:\n        const doesNextUpdateHaveData = nextValue.cells.length > 0;\n\n        let nextXIntervalTree: IntervalTree<string>, nextYIntervalTree: IntervalTree<string>;\n        if ((doesNextUpdateHaveData && nextValue.cells !== prevValue.cells) ||\n            prevStatus.status === AnimationStatus.Initial) {\n\n          const intervalTrees = getIntervalTrees(nextKeys, nextCells, createIntervalTree);\n          nextXIntervalTree = intervalTrees.xIntervalTree;\n          nextYIntervalTree = intervalTrees.yIntervalTree;\n        } else {\n          nextXIntervalTree = prevStatus.xIntervalTree;\n          nextYIntervalTree = prevStatus.yIntervalTree;\n        }\n\n        const tweenTarget = {tweenProgress: 0};\n\n        const timeline = new TimelineLite({paused: true});\n        const timelineStartTime = 0;\n\n        let textContainerStatus: TextContainerTransitionStatus;\n        if (nextValue.cells !== prevValue.cells ||\n            prevStatus.status === AnimationStatus.Initial) {\n          const {\n            rootNode, fragment, allCurrentlyAttachedDOMNodes,\n          } = getTextLabelFragment(nextCells, updatePattern, prevAttachedDOMNodes, domPoolRef.current);\n          textContainerStatus = {\n            isTextContainerChanging: true,\n            prevAttachedDOMNodes,\n            prevContainer: prevTextContainer,\n            nextAttachedDOMNodes: allCurrentlyAttachedDOMNodes,\n            nextContainer: rootNode,\n            fragment,\n          };\n        } else {\n          textContainerStatus = {\n            isTextContainerChanging: false,\n            currentAttachedDOMNodes: prevAttachedDOMNodes,\n            currentTextContainer: prevTextContainer,\n          };\n        }\n        if (textContainerStatus.isTextContainerChanging === true) {\n          timeline.set(textContainerStatus.nextContainer, {css: {opacity: 1}}, durationInSeconds / 2);\n          timeline.set(textContainerStatus.prevContainer, {css: {opacity: 0}}, timelineStartTime);\n        }\n\n        const setupVisibleDraw = (inputWidth: number, inputHeight: number) => {\n          gl.useProgram(cellProgram.program);\n          gl.uniform2f(cellProgram.uniforms.canvasSize, inputWidth, inputHeight);\n\n          vaoExtension.bindVertexArrayOES(cellsVAO);\n        };\n\n        const onAnimationUpdate = () => {\n          const {tweenProgress} = tweenTarget;\n\n          gl.uniform1f(cellProgram.uniforms.tweenProgress, tweenProgress);\n          // tslint:disable-next-line:no-bitwise\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n          instancedDrawingExtension.drawElementsInstancedANGLE(\n            gl.TRIANGLES, rectangleIndicesCount, cellProgram.indexBuffer.elementType, 0, cellsInfo.instancesCount,\n          );\n        };\n\n        const onAnimationComplete = () => {\n          vaoExtension.bindVertexArrayOES(null);\n\n          const endProspChangeTransition = () => {\n            statusRef.current = {\n              status: AnimationStatus.FinishedCompletely,\n              // cells related:\n              currentCells: nextCells,\n              currentKeys: nextKeys,\n              cellIndicesCount: rectangleIndicesCount,\n              cellInstancesCount: cellsInfo.instancesCount,\n              // Text related:\n              currentTextContainer: newTextContainer,\n              currentAttachedDOMNodes: newAttachedDOMNOdes,\n              // Hit test related:\n              xIntervalTree: nextXIntervalTree,\n              yIntervalTree: nextYIntervalTree,\n            };\n\n            done();\n          };\n          let newAttachedDOMNOdes: HTMLElement[], newTextContainer: HTMLElement;\n          if (textContainerStatus.isTextContainerChanging === true) {\n            newAttachedDOMNOdes = textContainerStatus.nextAttachedDOMNodes;\n            newTextContainer = textContainerStatus.nextContainer;\n            const domNodesToRemove = textContainerStatus.prevAttachedDOMNodes;\n            const textContainerToRemove = textContainerStatus.prevContainer;\n            requestAnimationFrame(() => {\n              const domPool = domPoolRef.current;\n              const prevAttachedDOMNodesLength = domNodesToRemove.length;\n              textContainerToRemove.remove();\n              for (let j = 0; j < prevAttachedDOMNodesLength; j += 1) {\n                domPool.enqueue(domNodesToRemove[j]);\n              }\n              endProspChangeTransition();\n            });\n\n          } else {\n            newAttachedDOMNOdes = textContainerStatus.currentAttachedDOMNodes;\n            newTextContainer = textContainerStatus.currentTextContainer;\n            endProspChangeTransition();\n          }\n        };\n        const animationTween = TweenLite.to(tweenTarget, durationInSeconds, {\n          tweenProgress: 1,\n          ease: 'Cubic.easeOut',\n          onUpdate: onAnimationUpdate,\n          onComplete: onAnimationComplete,\n        });\n        timeline.add(animationTween, timelineStartTime);\n\n        statusRef.current = {\n          status: AnimationStatus.InProgress, timeline,\n        };\n        setupVisibleDraw(nextValue.chartContainerWidth, nextValue.chartContainerHeight);\n        if (doesNextUpdateHaveData === true) {\n          requestAnimationFrame(() => {\n            if (textContainerStatus.isTextContainerChanging === true) {\n              rootEl.appendChild(textContainerStatus.fragment);\n            }\n\n            // If there's nothing to render in `nextProps` (usually due to error\n            // or all categories deselected), we want to just clear the screen\n            // instead of going through a draw operation:\n            requestAnimationFrame(() => {\n              timeline.play();\n            });\n          });\n\n        } else {\n          gl.clearColor(1, 1, 1, 1);\n          // tslint:disable-next-line:no-bitwise\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n          onAnimationComplete();\n        }\n\n      }\n    } else {\n      done();\n    }\n  } else {\n    done();\n  }\n};\nconst performHitTest = (input: {\n    status: Status,\n    mouseClientX: number | undefined,\n    mouseClientY: number | undefined,\n    canvas: HTMLCanvasElement | null,\n    chartWidth: number | undefined,\n    chartHeight: number | undefined,\n  }) => {\n\n  const {\n    status,\n    mouseClientX, mouseClientY,\n    canvas, chartWidth, chartHeight,\n  } = input;\n  if (mouseClientX !== undefined && mouseClientY !== undefined && canvas !== null &&\n      chartWidth !== undefined && chartHeight !== undefined) {\n    if (status.status === AnimationStatus.FinishedCompletely) {\n      const {top, left} = canvas.getBoundingClientRect();\n      const {xIntervalTree, yIntervalTree} = status;\n      const relativeX = mouseClientX - left;\n      const relativeY = mouseClientY - top;\n\n      const searchResult = searchForHits(\n        xIntervalTree, yIntervalTree, chartWidth, chartHeight, relativeX, relativeY,\n      );\n      return searchResult;\n    } else {\n      return undefined;\n    }\n  } else {\n    return undefined;\n  }\n\n};\n\nconst getUnthrottledHoverHandler = (input: {\n    statusRef: MutableRefObject<Status>,\n    canvasRef: MutableRefObject<HTMLCanvasElement | null>,\n    isTransitionInProgress: () => boolean,\n    onMouseOverCellRef: MutableRefObject<IProps['onMouseOverCell']>,\n    onMouseLeaveChartRef: MutableRefObject<IProps['onMouseLeaveChart']>,\n    chartWidthRef: MutableRefObject<IProps['chartContainerWidth']>\n    chartHeightRef: MutableRefObject<IProps['chartContainerHeight']>\n\n    // Note: need to update these refs every time before invoking the throttled\n    // version of `performHover`:\n    mouseClientXRef: MutableRefObject<number | undefined>,\n    mouseClientYRef: MutableRefObject<number | undefined>,\n  }) => {\n\n  const {\n    onMouseLeaveChartRef, onMouseOverCellRef, canvasRef,\n    mouseClientXRef, mouseClientYRef,\n    chartWidthRef, chartHeightRef,\n    statusRef, isTransitionInProgress,\n  } = input;\n\n  let hoveredNode: string | undefined;\n\n  return (input?: {cancel: boolean}) => {\n    const {current: status} = statusRef;\n    if (isTransitionInProgress() === false && status.status === AnimationStatus.FinishedCompletely) {\n      const prevHoveredNode = hoveredNode;\n      const {current: chartWidth} = chartWidthRef;\n      const {current: chartHeight} = chartHeightRef;\n      if (chartWidth !== undefined && chartHeight !== undefined) {\n        const nextHoveredNode = performHitTest({\n          status,\n          mouseClientX: mouseClientXRef.current,\n          mouseClientY: mouseClientYRef.current,\n          canvas: canvasRef.current,\n          chartWidth,\n          chartHeight,\n        });\n        hoveredNode = input && input.cancel ? undefined : nextHoveredNode;\n        const {current: onMouseOverCell} = onMouseOverCellRef;\n        const {current: onMouseLeaveChart} = onMouseLeaveChartRef;\n        if (nextHoveredNode !== prevHoveredNode) {\n          if (prevHoveredNode === undefined && nextHoveredNode !== undefined) {\n            onMouseOverCell(nextHoveredNode);\n          } else if (prevHoveredNode !== undefined && nextHoveredNode === undefined) {\n            onMouseLeaveChart();\n          } else if (prevHoveredNode !== undefined && nextHoveredNode !== undefined) {\n            onMouseOverCell(nextHoveredNode);\n          }\n        }\n      }\n    }\n  };\n\n};\n\nexport interface IProps {\n  highlighted: string | undefined;\n  cells: ITreeMapCell[];\n  comparisonTreeMap?: boolean;\n\n  numCellsTier: NumCellsTier;\n\n  chartContainerWidth: number ;\n  chartContainerHeight: number;\n\n  onCellClick: (id: string) => void;\n  onMouseOverCell: (id: string) => void;\n  onMouseLeaveChart: () => void;\n}\n\nexport default (props: IProps) => {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  const statusRef = useRef<Status>({status: AnimationStatus.Initial});\n  const glInfoRef = useRef<IGLInfo | undefined>(undefined);\n  const cellProgramRef = useRef<IProgramInfo | undefined>(undefined);\n  const domPoolRef = useRef<DOMPool>(new DOMPool(1000, 'div'));\n  const rootElRef = useRef<HTMLDivElement | null>(null);\n\n  const upgradeToLargeBufferRef = useRef(once(upgradeToLargeBuffer));\n\n  const {\n    numCellsTier, cells, highlighted,\n    chartContainerHeight, chartContainerWidth,\n  } = props;\n\n  const chartWidthRef = useTrackingRef(chartContainerWidth);\n  const chartHeightRef = useTrackingRef(chartContainerHeight);\n  const onMouseOverCellRef = useTrackingRef(props.onMouseOverCell);\n  const onMouseLeaveChartRef = useTrackingRef(props.onMouseLeaveChart);\n\n  useEffect(() => {\n    setupWebGL({numCellsTier, canvasRef, glInfoRef, cellProgramRef});\n    const {current: glInfo} = glInfoRef;\n    if (props.chartContainerWidth !== undefined &&\n        props.chartContainerHeight !== undefined &&\n        glInfo !== undefined) {\n      const {gl} = glInfo;\n      setWidthHeightInCSSPixels({\n        canvasRef,\n        widthInCSSPixelsRef: chartWidthRef,\n        heightInCSSPixelsRef: chartHeightRef,\n      });\n      resizeViewport(gl, true);\n    }\n\n    return () => {\n      const {current: innerGLInfo} = glInfoRef;\n      const {current: status} = statusRef;\n      if (innerGLInfo !== undefined) {\n        if (status.status === AnimationStatus.InProgress) {\n          const {timeline} = status;\n          (timeline as any).stop();\n        }\n        const {gl, cellGLBuffer} = innerGLInfo;\n        innerGLInfo.cellBuffer = null as any;\n        gl.deleteBuffer(cellGLBuffer);\n      }\n    };\n  }, []);\n\n  const {\n    isTransitionInProgress,\n  } = usePropsChangeRateLimiter<IPropsChangeHandlerExtraInputs, IMonitoredProps>({\n    value: {\n      cells, highlighted, numCellsTier,\n      chartContainerHeight, chartContainerWidth,\n      comparisonTreeMap: props.comparisonTreeMap,\n    },\n    getExtraInputToPropsChangeHandler: () => ({\n      glInfoRef, cellProgramRef,\n      widthInCSSPixelsRef: chartWidthRef,\n      heightInCSSPixelsRef: chartHeightRef,\n      statusRef, domPoolRef, upgradeToLargeBufferRef,\n      rootElRef,\n    }),\n    performPropsChange,\n  });\n\n  const mouseClientXRef = useRef<number | undefined>(undefined);\n  const mouseClientYRef = useRef<number | undefined>(undefined);\n\n  const unthrottledHoverHandler = getUnthrottledHoverHandler({\n    statusRef, canvasRef, isTransitionInProgress,\n    onMouseOverCellRef, onMouseLeaveChartRef, chartWidthRef, chartHeightRef,\n    mouseClientXRef, mouseClientYRef,\n  });\n\n  // We perform hover hit test at 20fps:\n  const throttledPerformHoverRef = useRef(\n    throttle(unthrottledHoverHandler, millisecondsPerSeconds / hoverContinuousHitTestFrameRate),\n  );\n\n  const onMouseLeave = () => {\n    const {current: throttledHover} = throttledPerformHoverRef;\n    if (isTransitionInProgress() === false) {\n      throttledHover({cancel: true});\n    }\n    props.onMouseLeaveChart();\n  };\n\n  const onMouseMove = ({clientX, clientY}: React.MouseEvent<any>) => {\n    mouseClientXRef.current = clientX;\n    mouseClientYRef.current = clientY;\n    const {current: throttledPerformHover} = throttledPerformHoverRef;\n    if (isTransitionInProgress() === false) {\n      throttledPerformHover();\n    }\n  };\n\n  const onClick = () => {\n    if (isTransitionInProgress() === false) {\n      const {current: status} = statusRef;\n      if (status.status === AnimationStatus.FinishedCompletely) {\n        const result = performHitTest({\n          status,\n          mouseClientX: mouseClientXRef.current,\n          mouseClientY: mouseClientYRef.current,\n          canvas: canvasRef.current,\n          chartWidth: chartContainerWidth,\n          chartHeight: chartContainerHeight,\n        });\n        if (result !== undefined) {\n          props.onCellClick(result);\n        }\n      }\n    }\n\n  };\n\n  return (\n    <Root ref={rootElRef}\n      onMouseLeave={onMouseLeave}\n      onMouseMove={onMouseMove}\n      onClick={onClick}\n      style={{width: props.chartContainerWidth, height: chartContainerHeight}}\n    >\n      <canvas\n        ref={canvasRef}\n        style={{width: props.chartContainerWidth, height: chartContainerHeight}}\n      />\n    </Root>\n  );\n\n};\n","import {\n  useEffect,\n  useRef,\n} from 'react';\n\nexport interface PropsChangeHandlerInput<PropsChangeHandlerExtraInputs, Props> {\n  prevValue: Props | undefined;\n  nextValue: Props;\n  extraInputs: PropsChangeHandlerExtraInputs;\n  done: () => void;\n}\n\ninterface IInput<PropsChangeHandlerExtraInputs, Props> {\n  getExtraInputToPropsChangeHandler: () => PropsChangeHandlerExtraInputs;\n  value: Props;\n  performPropsChange: (input: PropsChangeHandlerInput<PropsChangeHandlerExtraInputs, Props>) => void;\n}\n\nexport default <PropsChangeHandlerExtraInputs, Props>(\n    input: IInput<PropsChangeHandlerExtraInputs, Props>) => {\n\n  const {\n    value, getExtraInputToPropsChangeHandler,\n    performPropsChange,\n  } = input;\n  const nextValueRef = useRef<Props | undefined>(undefined);\n  const prevValueRef = useRef<Props | undefined>(undefined);\n  const isTransitionInProgressRef = useRef<boolean>(false);\n\n  const onPropsChangeComplete = () => {\n    isTransitionInProgressRef.current = false;\n    performNextValueChange();\n  };\n\n  const performNextValueChange = () => {\n    const {current: nextValue} = nextValueRef;\n    const {current: prevValue} = prevValueRef;\n    if (nextValue !== undefined && isTransitionInProgressRef.current === false) {\n      prevValueRef.current = nextValue;\n      nextValueRef.current = undefined;\n      if (prevValue === undefined) {\n        isTransitionInProgressRef.current = true;\n        const extraInputs = getExtraInputToPropsChangeHandler();\n        performPropsChange({\n          prevValue, nextValue,\n          extraInputs, done: onPropsChangeComplete,\n        });\n      } else {\n        if (nextValue !== prevValue) {\n          isTransitionInProgressRef.current = true;\n          const extraInputs = getExtraInputToPropsChangeHandler();\n          performPropsChange({\n            prevValue, nextValue,\n            extraInputs, done: onPropsChangeComplete,\n          });\n        }\n      }\n    }\n  };\n\n  useEffect(() => {\n    nextValueRef.current = value;\n    performNextValueChange();\n  }, [value]);\n\n  return {\n    isTransitionInProgress: () => isTransitionInProgressRef.current,\n  };\n};\n","import initial from 'lodash/initial';\nimport last from 'lodash/last';\nimport sum from 'lodash/sum';\nimport {\n  ellipsisCharacter as ellipsis,\n} from './Utils';\n\nconst wordSeparator = ' ';\n\ninterface IFontMeasurement {\n  maxCharacterWidth: number;\n  maxCharacterHeight: number;\n}\n\ninterface IRectangle {\n  width: number;\n  height: number;\n}\n\ninterface IWord {\n  text: string;\n  width: number;\n}\n\ntype ILayoutAttemptResult = {\n  success: boolean,\n  // Each element in the array represents a row. Each row is in turn an array of\n  // words.\n  lines: ILine[];\n};\n\ninterface ILine {\n  text: string;\n  words: IWord[];\n}\n\nconst attemptFitTextInsideRectangle = (input: {\n    text: string,\n    referenceMeasurement: IFontMeasurement,\n    referenceFontSize: number,\n    rectangle: IRectangle,\n    fontSizeToTry: number;\n  }): ILayoutAttemptResult => {\n\n  const {\n    text, referenceMeasurement, referenceFontSize, rectangle, fontSizeToTry,\n  } = input;\n\n  // Scale up/down the measured width/height according to the `fontSizeToTry`:\n  const maxCharacterHeight = fontSizeToTry / referenceFontSize * referenceMeasurement.maxCharacterHeight;\n  const maxCharacterWidth = fontSizeToTry / referenceFontSize * referenceMeasurement.maxCharacterWidth;\n\n  const {width, height} = rectangle;\n  const maxLineNumber = Math.floor(height / maxCharacterHeight);\n  const words: IWord[] = text.split(wordSeparator).map(word => ({\n    text: word,\n    width: word.length * maxCharacterWidth,\n  }));\n  const [firstWord, ...remainingWords] = words;\n\n  const isEveryWordShorterThanRectangle = words.every(word => word.width < width);\n\n  // If at least one word is longer than the rectangle's width or the\n  // rectangle's height is shorter than the height of a single lint of text, the\n  // text is too big to fit.\n  if (!isEveryWordShorterThanRectangle || maxCharacterHeight > height) {\n\n    return {\n      success: false,\n      lines: [],\n    };\n\n  } else {\n    const fitResult: IWord[][] = [ [firstWord] ];\n\n    let lineNumber = 1;\n    // Because (the area of the first word) < (total rectangle area), we know\n    // the first word will fit:\n    let lineLengthLeft = width - firstWord.width;\n\n    // Keep doing this as long as there are still words remaining and we haven't\n    // run out of space in the rectangle:\n    while (remainingWords.length) {\n\n      const wordToFit = remainingWords.shift()!;\n      if (wordToFit.width < lineLengthLeft) {\n        // If there's enough space left on the current line for the word then add\n        // it to the line:{\n        const [lastFitResult] = fitResult.slice(-1);\n        lastFitResult.push(wordToFit);\n        // Need to also subtract the width by the amount taken by the space\n        // separating the words:\n        lineLengthLeft = lineLengthLeft - wordToFit.width - maxCharacterWidth;\n      } else {\n       // Else, start a new line if possible\n        lineNumber = lineNumber + 1;\n        fitResult.push([]);\n        // Return the attempted word to the pool of remaining words to fit:\n        remainingWords.unshift(wordToFit!);\n        lineLengthLeft = width;\n      }\n    }\n\n    const lines: ILine[] = fitResult.map(wordsInLine => {\n      const wordsBeforeLast = initial(wordsInLine);\n      const lastWord = last(wordsInLine)!;\n      const newWordsBeforeLast = wordsBeforeLast.map(word => ({\n        text: word.text + wordSeparator,\n        width: word.width + maxCharacterWidth,\n      }));\n      const newWords = [...newWordsBeforeLast, lastWord];\n      const newText = newWords.map(word => word.text).join('');\n      return {\n        text: newText,\n        words: newWords,\n      };\n    });\n    const isSuccessful = (lines.length <= maxLineNumber);\n\n    return {\n      success: isSuccessful,\n      lines,\n    };\n  }\n};\n\ninterface IFontSizeDetermination {\n  fontSize: number;\n  lines: ILine[];\n}\n\nexport const determineFontSizeToFit = (\n  input: {\n    text: string,\n    referenceMeasurement: IFontMeasurement,\n    referenceFontSize: number,\n    rectangle: IRectangle,\n  }): IFontSizeDetermination => {\n\n  const {text, referenceFontSize, referenceMeasurement, rectangle} = input;\n  const {maxCharacterHeight, maxCharacterWidth} = referenceMeasurement;\n  const {width, height} = rectangle;\n  const totalTextArea = text.length * maxCharacterHeight * maxCharacterWidth;\n  const totalRectangleArea = width * height;\n\n  // This is the font size for which the total text area = rectangle's area.\n  // This is the max font size the text can possibly have:\n  const maxFontSize = (Math.sqrt((totalRectangleArea / totalTextArea) * Math.pow(16, 2)));\n\n  // Use bisection to figure out the optimize font size. Stop when the two bounds\n  // converge to within 0.01:\n  let upperBound = maxFontSize;\n  let lowerBound = 0;\n  let sizeToTry: number | undefined;\n  let layoutResult: ILine[] | undefined;\n  while (Math.abs(upperBound - lowerBound) > 0.01) {\n    sizeToTry = (upperBound + lowerBound) / 2;\n    // TODO: memoize this function call:\n    const layoutAttempt = attemptFitTextInsideRectangle({\n      text, referenceMeasurement, referenceFontSize, rectangle,\n      fontSizeToTry: sizeToTry,\n    });\n    let newUpperBound: number, newLowerBound: number;\n    if (layoutAttempt.success) {\n      layoutResult = layoutAttempt.lines;\n      newUpperBound = upperBound;\n      newLowerBound = sizeToTry;\n    } else {\n      newUpperBound = sizeToTry;\n      newLowerBound = lowerBound;\n    }\n    upperBound = newUpperBound;\n    lowerBound = newLowerBound;\n  }\n\n  return {\n    fontSize: sizeToTry!,\n    lines: layoutResult!,\n  };\n};\n\nexport const truncateTextInRectangle = (input: {\n    text: string,\n    referenceMeasurement: IFontMeasurement,\n    referenceFontSize: number,\n    rectangle: IRectangle,\n    fontSizeToTry: number;\n  }): ILine[] => {\n\n  const {\n    fontSizeToTry, referenceFontSize,\n    referenceMeasurement,\n    rectangle: {height, width},\n  } = input;\n  const maxCharacterHeight = fontSizeToTry / referenceFontSize * referenceMeasurement.maxCharacterHeight;\n  const maxCharacterWidth = fontSizeToTry / referenceFontSize * referenceMeasurement.maxCharacterWidth;\n\n  const isEveryWordShorterThanRectangle = input.text.split(wordSeparator).every(\n    word => word.length * maxCharacterWidth < width,\n  );\n\n  let result: ILine[];\n  if (isEveryWordShorterThanRectangle === false) {\n    // If at least one word is longer the rectangle, the layout algorithm won't be able to fit the text in.\n    // In that case, just trim the first word\n    const firstWord = input.text.split(wordSeparator)[0];\n    const maxCharacterCountToFitWidth = Math.floor(width / maxCharacterWidth);\n    const trimmedFirstWord = `${firstWord.slice(0, maxCharacterCountToFitWidth)}${ellipsis}`;\n    result = [{\n      text: trimmedFirstWord,\n      words: [{\n        text: trimmedFirstWord,\n        width: maxCharacterCountToFitWidth * maxCharacterWidth,\n      }],\n    }];\n\n  } else {\n    const maxNumOfLines = Math.floor(height / maxCharacterHeight);\n    const {lines} = attemptFitTextInsideRectangle(input);\n\n    if (lines.length > 0) {\n      // Only keep the lines that fit vertically within the rectangle:\n      const retainedLines = lines.slice(0, maxNumOfLines);\n      const linesBeforeLast = initial(retainedLines);\n      const lastLine = last(retainedLines)!;\n\n      // Add ellipsis to the end of the last line:\n      const totalLengthOfLastLine = sum(lastLine.words.map(word => word.width));\n      let newLastLine: ILine;\n      if (totalLengthOfLastLine < width - maxCharacterWidth) {\n        // If there's enough leftover space on the last line for the ellipsis, simply append\n        // the ellipsis after the last character:\n        const {words} = lastLine;\n        const wordsOtherThanLast = initial(words);\n        const lastWord = last(words)!;\n        const newLastWord = {\n          text: lastWord.text + ellipsis,\n          width: lastWord.width + maxCharacterWidth,\n        };\n        newLastLine = {\n          text: lastLine.text + ellipsis,\n          words: [...wordsOtherThanLast, newLastWord],\n        };\n      } else {\n        // Otherwise, relace the last character with the ellipsis:\n        const {words} = lastLine;\n        const wordsBeforeLast = initial(words);\n        const lastWord = last(words)!;\n        const newLastWord = {\n          text: lastWord.text.replace(/.$/, ellipsis),\n          width: lastWord.width,\n        };\n        newLastLine = {\n          text: lastLine.text.replace(/.$/, ellipsis),\n          words: [...wordsBeforeLast, newLastWord],\n        };\n      }\n\n      result = [...linesBeforeLast, newLastLine];\n    } else {\n      result = [];\n    }\n\n  }\n\n  return result;\n};\n","import {\n  LabelLayout,\n  ShareLayout,\n  TextLayout,\n  TextLayoutType,\n} from './otherTypes';\nimport {\n  heightProportionReservedForShare,\n  labelHorizontalMargin,\n  labelTopMargin,\n  minNodeNameFontSize,\n} from './transformUtils';\nimport {\n  determineFontSizeToFit,\n  truncateTextInRectangle,\n} from './fitTextInRectangle';\n\ninterface Rect {\n  x0: number;\n  y0: number;\n  x1: number;\n  y1: number;\n}\n\nexport type WithTextLayout<T> = T & {\n  textLayout: TextLayout;\n};\n\nconst addTextLayout = <T extends Rect>(input: {\n    datum: T,\n    referenceFontSize: number,\n    measuredCharacterHeight: number,\n    measuredCharacterWidth: number,\n    maxCharacterHeightAtMinFontSize: number,\n    cellLabel: string,\n    cellValue: string,\n  }) => {\n  const {\n    datum, referenceFontSize, measuredCharacterHeight, measuredCharacterWidth,\n    maxCharacterHeightAtMinFontSize, cellLabel, cellValue,\n  } = input;\n  const {x0, y0, x1, y1} = datum;\n  const fullWidth = x1 - x0;\n  const fullHeight = y1 - y0;\n\n  const widthMinusMargin = fullWidth * (1 - 2 * labelHorizontalMargin);\n  const fullAvailableHeightForLabel = fullHeight * (1 - heightProportionReservedForShare);\n  const heightMinusMargin = fullAvailableHeightForLabel * (1 - labelTopMargin);\n\n  // First try to fit text with margin:\n  const labelLayoutWithMargin = determineFontSizeToFit({\n    text: cellLabel,\n    referenceFontSize,\n    referenceMeasurement: {\n      maxCharacterHeight: measuredCharacterHeight,\n      maxCharacterWidth: measuredCharacterWidth,\n    },\n    rectangle: {width: widthMinusMargin, height: heightMinusMargin},\n  });\n\n  //#region Label layout\n  let labelLayout: LabelLayout;\n  if (labelLayoutWithMargin.fontSize > minNodeNameFontSize) {\n    const textSplitIntoLines = labelLayoutWithMargin.lines.map(line => line.text);\n    labelLayout = {\n      showText: true,\n      fontSize: labelLayoutWithMargin.fontSize,\n      textSplitIntoLines,\n      textUnsplit: textSplitIntoLines.join(' '),\n      useMargin: true,\n    };\n  } else {\n    // If text doesn't fit when margin is present, try again without margin:\n    const layoutResultWithoutMargin = determineFontSizeToFit({\n      text: cellLabel,\n      referenceFontSize,\n      referenceMeasurement: {\n        maxCharacterHeight: measuredCharacterHeight,\n        maxCharacterWidth: measuredCharacterWidth,\n      },\n      rectangle: {width: fullWidth, height: fullAvailableHeightForLabel},\n    });\n    if (layoutResultWithoutMargin.fontSize > minNodeNameFontSize) {\n      const textSplitIntoLines = layoutResultWithoutMargin.lines.map(line => line.text);\n      labelLayout = {\n        showText: true,\n        fontSize: layoutResultWithoutMargin.fontSize,\n        textSplitIntoLines,\n        textUnsplit: textSplitIntoLines.join(' '),\n        useMargin: false,\n      };\n    } else {\n      // When removing margin still doesn't fit the text, truncate the text if\n      // the height can accommodate at least three lines of text:\n      if (fullAvailableHeightForLabel > 3 * maxCharacterHeightAtMinFontSize) {\n        const truncatedLines = truncateTextInRectangle({\n          text: cellLabel,\n          referenceFontSize,\n          referenceMeasurement: {\n            maxCharacterHeight: measuredCharacterHeight,\n            maxCharacterWidth: measuredCharacterWidth,\n          },\n          rectangle: {width: fullWidth, height: fullAvailableHeightForLabel},\n          fontSizeToTry: minNodeNameFontSize,\n        });\n        if (truncatedLines.length > 0) {\n          const textSplitIntoLines = truncatedLines.map(line => line.text);\n          labelLayout = {\n            showText: true,\n            fontSize: minNodeNameFontSize,\n            textSplitIntoLines,\n            textUnsplit: textSplitIntoLines.join(' '),\n            useMargin: false,\n          };\n        } else {\n          labelLayout = {showText: false};\n        }\n      } else {\n        labelLayout = {showText: false};\n      }\n    }\n  }\n  //#endregion\n\n  //#region Percentage layout:\n  const heightAvailableForPercentage = fullHeight * heightProportionReservedForShare;\n  let textLayout: TextLayout, shareLayout: ShareLayout;\n  if (labelLayout.showText === true) {\n    // If layout for label is succesful, only use the space that's reserved for\n    // the percentage:\n    const layoutResultPartialCell = determineFontSizeToFit({\n      text: cellValue,\n      referenceFontSize,\n      referenceMeasurement: {\n        maxCharacterHeight: measuredCharacterHeight,\n        maxCharacterWidth: measuredCharacterWidth,\n      },\n      rectangle: {width: fullWidth, height: heightAvailableForPercentage},\n    });\n\n    // Make sure that the percentage doesn't extend more than one line:\n    if (layoutResultPartialCell.fontSize > minNodeNameFontSize &&\n        layoutResultPartialCell.lines.length <= 1) {\n\n      shareLayout = {\n        showText: true,\n        fontSize: layoutResultPartialCell.fontSize,\n        text: cellValue,\n      };\n      textLayout = {\n        type: TextLayoutType.ShowBoth,\n        share: shareLayout,\n        label: labelLayout,\n      };\n    } else {\n      shareLayout = {\n        showText: false,\n      };\n      textLayout = {\n        type: TextLayoutType.ShowNone,\n      };\n    }\n  } else {\n    // If label text is not shown, let the percentage take up the entire space:\n    const layoutResultFullCell = determineFontSizeToFit({\n      text: cellValue,\n      referenceFontSize,\n      referenceMeasurement: {\n        maxCharacterHeight: measuredCharacterHeight,\n        maxCharacterWidth: measuredCharacterWidth,\n      },\n      rectangle: {width: fullWidth, height: fullHeight},\n    });\n\n    if (layoutResultFullCell.fontSize > minNodeNameFontSize &&\n        layoutResultFullCell.lines.length <= 1) {\n\n      shareLayout = {\n        showText: true,\n        fontSize: layoutResultFullCell.fontSize,\n        text: cellValue,\n      };\n      textLayout = {\n        type: TextLayoutType.ShowOnlyShare,\n        share: shareLayout,\n      };\n    } else {\n      textLayout = {\n        type: TextLayoutType.ShowNone,\n      };\n    }\n  }\n\n  //#endregion\n\n  const result: WithTextLayout<T> = {\n    ...datum,\n    textLayout,\n  };\n\n  return result;\n};\n\nexport default addTextLayout;\n","import sortBy from 'lodash/sortBy';\nimport sum from 'lodash/sum';\nimport squarify, {\n  Input,\n  IRect,\n} from 'squarify';\nimport {\n  groupByMap,\n} from './Utils';\n\nexport type WithRect<T> = T & {\n  x0: number;\n  y0: number;\n  x1: number;\n  y1: number;\n};\ninterface IWithTopLevelParentId {\n  monetaryValue: number;\n  // id: string\n  // shortName: string\n  topLevelParentId: string;\n}\n\nconst performLayout = <T extends IWithTopLevelParentId>(\n    list: T[], container: IRect,\n  ): Array<WithRect<T>> => {\n\n  type AugmentedElement = T & {value: number, children: undefined};\n\n  const groupedBySection = groupByMap(list, ({topLevelParentId}) => topLevelParentId);\n  const result: Array<Input<T>> = [];\n  for (const [sectionId, elemsInSection] of (groupedBySection as any)) {\n    const sortedElemsInSection = sortBy(elemsInSection, 'monetaryValue').reverse();\n    const elemsWithValue: AugmentedElement[] = sortedElemsInSection.map(elem => ({\n      ...elem,\n      value: elem.monetaryValue,\n      children: undefined,\n    }));\n    const sectionSum = sum(sortedElemsInSection.map(({monetaryValue}) => monetaryValue));\n    const firstElem = elemsWithValue[0];\n    const sectionResult: Input<T> = {\n      // Spread in one element to satisfy the type checker:\n      ...firstElem,\n\n      value: sectionSum,\n      children: elemsWithValue,\n      id: sectionId,\n    };\n    result.push(sectionResult);\n  }\n  const sorted = sortBy(result, 'value').reverse();\n\n  const rawLayoutOutput = squarify<T>(sorted, container);\n  const cleanedOutput = rawLayoutOutput.map(elem => {\n    const {\n      x0, y0, x1, y1, normalizedValue, value, children, ...rest\n    } = elem;\n    const out = {\n      x0, y0, x1, y1,\n      ...rest,\n    } as unknown as WithRect<T>;\n    return out;\n  });\n  return cleanedOutput;\n};\n\nexport default performLayout;\n","import * as React from 'react'\nimport Chart, {IProps} from './chart/chart';\nimport treemapCellTransformer, {Inputs, Output} from './transformers/treemapCellTransformer';\n\nconst transformData: (inputs: Inputs) => Output = treemapCellTransformer;\nexport {\n  transformData, Inputs, Output,\n}\n\nexport default (props: IProps) => {\n  return (\n    <Chart {...props} />\n  );\n}\n","import sum from 'lodash/sum';\nimport {formatPercentage } from './numberFormatters';\nimport addTextLayout from '../chart/addTextLayout';\nimport {\n  ITreeMapCell,\n} from '../chart/otherTypes';\nimport performLayout, { WithRect } from '../chart/performLayout';\nimport {\n  computeGrossNetTradeValues,\n  filterByMonetaryValues,\n  maxCharacterHeightAtMinFontSize,\n} from '../chart/transformUtils';\nimport {\n  measuredCharacterHeight,\n  measuredCharacterWidth,\n  referenceFontSize,\n} from '../chart/Utils';\nimport mergeComparisonData, {ComparisonTreeMapCells} from './mergeComparisonData';\n\nexport interface Datum {\n  id: string;\n  value: number;\n  title: string;\n  topLevelParentId: string;\n}\n\nexport interface ComparisonDatum extends Datum {\n  primaryValue: number;\n  secondaryValue: number;\n}\n\ninterface ColorMap {\n  id: string;\n  color: string;\n}\n\nexport interface Inputs {\n  data: Datum[];\n  comparisonData?: Datum[];\n  width: number;\n  height: number;\n  colorMap: ColorMap[];\n}\n\nexport interface Output {\n  treeMapCells: ITreeMapCell[];\n}\n\nexport interface Transformed {\n  id: string;\n  label: string;\n  monetaryValue: number;\n  topLevelParentId: string;\n  percentage: number;\n}\n\nconst treemapCellTransformer = (inputs: Inputs): Output => {\n  const {\n    width, height, colorMap,\n  } = inputs;\n  let data: (Datum[]) | (ComparisonDatum[]);\n  let createComparisionCells: ((layoutCell: ITreeMapCell) => ComparisonTreeMapCells) | undefined;\n  if (inputs.comparisonData !== undefined) {\n    const merged = mergeComparisonData(inputs.data, inputs.comparisonData);\n    data = merged.data;\n    createComparisionCells = merged.createComparisionCells;\n  } else {\n    data = inputs.data;\n    createComparisionCells = undefined;\n  }\n  const withComputedTradeValues = computeGrossNetTradeValues(data);\n  const filteredByMonetaryValue = filterByMonetaryValues(withComputedTradeValues);\n  const totalSum = sum(filteredByMonetaryValue.map(({monetaryValue}) => monetaryValue));\n  const transformed: Transformed[] = [];\n  for (const elem of filteredByMonetaryValue) {\n    const {\n      monetaryValue, topLevelParentId, id, title,\n    } = elem;\n    const percentage = monetaryValue / totalSum;\n\n    const out: Transformed = {\n      id,\n      label: title,\n      monetaryValue,\n      topLevelParentId,\n      percentage,\n    };\n    transformed.push(out);\n\n  }\n  const container = {\n    x0: 0, y0: 0, x1: width, y1: height,\n  };\n  const withCellLayout: Array<WithRect<Transformed>> = performLayout(transformed, container);\n  const withTextLayout = withCellLayout.map(elem => {\n    const cellValue: string = formatPercentage(elem.percentage);\n    return addTextLayout({\n      datum: elem,\n      referenceFontSize, measuredCharacterHeight,\n      measuredCharacterWidth, maxCharacterHeightAtMinFontSize,\n      cellLabel: elem.label,\n      cellValue,\n    });\n  });\n\n  let treeMapCells: ITreeMapCell[] = [];\n  withTextLayout.forEach(({topLevelParentId, monetaryValue, ...rest}) => {\n    const tagetColor = colorMap.find(c => c.id === topLevelParentId);\n    if (tagetColor === undefined) {\n      throw new Error('Cannot find color for top section ' + topLevelParentId);\n    }\n    const out: ITreeMapCell = {\n      ...rest,\n      color: tagetColor.color,\n      value: monetaryValue,\n    };\n    if (inputs.comparisonData !== undefined && createComparisionCells !== undefined) {\n      const mergedCells = createComparisionCells(out)\n      mergedCells.forEach(cell => treeMapCells.push(cell));\n    } else {\n      treeMapCells.push(out);\n    }\n  });\n\n  return {treeMapCells};\n};\n\nexport default treemapCellTransformer;\n\n","import {\n  Datum,\n  ComparisonDatum,\n} from './treemapCellTransformer';\nimport {\n  ITreeMapCell,\n  TextLayoutType,\n  TextLayout,\n} from '../chart/otherTypes';\nimport {lighten} from 'polished';\n\ntype TextCell = ITreeMapCell;\ntype PrimaryCell = ITreeMapCell;\ntype SecondaryCell = ITreeMapCell;\ntype BorderBottomCell = ITreeMapCell;\ntype BorderRightCell = ITreeMapCell;\n\nexport type ComparisonTreeMapCells = [\n  TextCell,\n  PrimaryCell,\n  SecondaryCell,\n  BorderBottomCell,\n  BorderRightCell,\n]\n\ninterface Output {\n  data: ComparisonDatum[];\n  createComparisionCells: (layoutCell: ITreeMapCell) => ComparisonTreeMapCells;\n}\n\nexport default (primaryData: Datum[], secondaryData: Datum[]): Output => {\n  // merge all data points from dataset 2 into dataset 1\n  const data = primaryData.map(d1 => {\n    const d2 = secondaryData.find(({id}) => id === d1.id);\n    const secondaryValue = d2 && d2.value ? d2.value : 0;\n    return {...d1, value: d1.value + secondaryValue, primaryValue: d1.value, secondaryValue};\n  })\n  // Add any datapoints that only exist in dataset 2\n  secondaryData.filter(({id}) => !primaryData.find(d => d.id === id))\n               .forEach(d => data.push({...d, primaryValue: 0, secondaryValue: d.value}));\n\n  const createComparisionCells = (layoutCell: ITreeMapCell): ComparisonTreeMapCells => {\n    const targetDatum = data.find(({id}) => id === layoutCell.id);\n    if (!targetDatum) {\n      console.error({'Invalid cell': layoutCell});\n      throw new Error('Invalid layoutCell id ' + layoutCell.id + 'at mergeComparisonData');\n    }\n    let textLayout: TextLayout;\n    if (layoutCell.textLayout.type === TextLayoutType.ShowBoth) {\n      textLayout = {\n        type: TextLayoutType.ShowBoth,\n        label: {...layoutCell.textLayout.label},\n        share: {showText: false},\n      }\n    } else {\n      textLayout = { type: TextLayoutType.ShowNone };\n    }\n    const textCell: TextCell = {\n      ...layoutCell,\n      id: 'text-cell-' + layoutCell.id,\n      textLayout,\n      color: 'transparent',\n    }\n    const primaryCell: PrimaryCell = {\n      ...layoutCell,\n      id: 'primary-cell-' + layoutCell.id,\n      x1: layoutCell.x1 - ((layoutCell.x1 - layoutCell.x0) * (targetDatum.secondaryValue / targetDatum.value)),\n      textLayout: { type: TextLayoutType.ShowNone },\n      comparison: true,\n    }\n    const secondaryCell: SecondaryCell = {\n      ...layoutCell,\n      id: 'secondary-cell-' + layoutCell.id,\n      x0: primaryCell.x1,\n      color: lighten(0.1, layoutCell.color),\n      textLayout: { type: TextLayoutType.ShowNone },\n      comparison: true,\n    }\n    const borderBottom: BorderBottomCell = {\n      ...layoutCell,\n      id: 'border-bottom-' + layoutCell.id,\n      y0: layoutCell.y1 - 0.5,\n      color: 'white',\n      comparison: true,\n      textLayout: { type: TextLayoutType.ShowNone },\n    }\n    const borderRight: BorderRightCell = {\n      ...layoutCell,\n      id: 'border-right-' + layoutCell.id,\n      x0: layoutCell.x1 - 0.5,\n      color: 'white',\n      comparison: true,\n      textLayout: { type: TextLayoutType.ShowNone },\n    }\n    return [textCell, primaryCell, secondaryCell, borderBottom, borderRight];\n  }\n  return {data, createComparisionCells};\n}\n\n","import {\n  format,\n} from 'd3-format';\n\nexport const formatPercentage =\n  (percentage: number, decimalPlaces: number = 2) => format(`.${decimalPlaces}%`)(percentage);\n","import React, {useState} from 'react'\nimport raw from 'raw.macro';\nimport TreeMap, {transformData} from 'react-canvas-treemap';\nimport styled from 'styled-components/macro';\n\nconst Grid = styled.div`\n  display: grid;\n  grid-template-columns: 500px 500px;\n  grid-gap: 1rem;\n  margin-bottom: 2rem;\n`;\n\nconst destBostonDataRaw = JSON.parse(raw('../data/treemap_dest_boston_all_industry.json'));\n\nlet colorMap: Array<{id: string, color: string}> = [];\ndestBostonDataRaw.forEach(({topLevelParentId, color}: {topLevelParentId: string, color: string}) => {\n  if (!colorMap.find(({id}) => id === topLevelParentId)) {\n    colorMap.push({id: topLevelParentId, color});\n  }\n})\n\nconst destBostonData = transformData({\n  data: destBostonDataRaw,\n  width: 500,\n  height: 500,\n  colorMap: colorMap,\n});\n\n\nconst originBostonDataRaw = JSON.parse(raw('../data/treemap_origin_boston_all_industry.json'));\n\nconst originBostonData = transformData({\n  data: originBostonDataRaw,\n  width: 500,\n  height: 500,\n  colorMap: colorMap,\n});\n\n\nconst employeeBostonDataRaw = JSON.parse(raw('../data/boston_dest_employees.json'));\n\nlet cityColorMap: Array<{id: string, color: string}> = [];\nemployeeBostonDataRaw.forEach(({topLevelParentId, color}: {topLevelParentId: string, color: string}) => {\n  if (!cityColorMap.find(({id}) => id === topLevelParentId)) {\n    cityColorMap.push({id: topLevelParentId, color});\n  }\n})\n\nconst employeeBostonData = transformData({\n  data: employeeBostonDataRaw,\n  width: 500,\n  height: 500,\n  colorMap: cityColorMap,\n});\n\nconst filteredToUSA = employeeBostonDataRaw.filter(({topLevelParentId}: {topLevelParentId: string}) => topLevelParentId === 'USA');\n\nconst filteredBostonData = transformData({\n  data: filteredToUSA,\n  width: 500,\n  height: 500,\n  colorMap: cityColorMap,\n});\n\n\nenum NumCellsTier {\n  // Use `Small` for all type of tree maps except for product tree maps at\n  // 6-digit detail level:\n  Small,\n  Large,\n}\n\n\nenum Direction {\n  Dest,\n  Origin,\n}\n\nconst App = () => {\n  const [direction, setDirection] = useState<Direction>(Direction.Dest);\n  const [filtered, setFiltered] = useState<boolean>(false);\n\n  const toggleDirection = () => {\n    if (direction === Direction.Dest) {\n      setDirection(Direction.Origin);\n    } else {\n      setDirection(Direction.Dest);\n    }\n  }\n\n  return (\n    <div>\n      <Grid>\n        <div>\n          <button onClick={toggleDirection}>\n            Toggle Data\n          </button>\n          <TreeMap\n            highlighted={undefined}\n            cells={direction === Direction.Dest ? destBostonData.treeMapCells : originBostonData.treeMapCells}\n            numCellsTier={NumCellsTier.Small}\n            chartContainerWidth={500}\n            chartContainerHeight={500}\n            onCellClick={id => console.log(id)}\n            onMouseOverCell={id => console.log(id)}\n            onMouseLeaveChart={() => {}}\n          />\n        </div>\n        <div>\n          <button onClick={() => setFiltered(!filtered)}>\n            Toggle Filter\n          </button>\n          <TreeMap\n            highlighted={undefined}\n            cells={filtered ? filteredBostonData.treeMapCells : employeeBostonData.treeMapCells}\n            numCellsTier={NumCellsTier.Small}\n            chartContainerWidth={500}\n            chartContainerHeight={500}\n            onCellClick={id => console.log(id)}\n            onMouseOverCell={id => console.log(id)}\n            onMouseLeaveChart={() => {}}\n          />\n        </div>\n      </Grid>\n    </div>\n  );\n}\n\nexport default App\n","import React, {useState} from 'react'\nimport raw from 'raw.macro';\nimport TreeMap, {transformData, Output as TransformedData} from 'react-canvas-treemap';\nimport styled from 'styled-components/macro';\n\nconst Container = styled.div`\n  width: 500px;\n  height: 500px;\n  margin-bottom: 2rem;\n`;\n\nconst Nav = styled.nav`\n  display: flex;\n`;\n\nconst Button = styled.button`\n  margin-right: 1rem;\n  cursor: pointer;\n`;\n\ninterface NaicsDatum {\n  code: string;\n  code_hierarchy: string;\n  level: number;\n  naics_id: number;\n  naics_id_hierarchy: string;\n  name: string;\n  parent_code: null | string;\n  parent_id: null | number;\n}\n\nconst naicsData: NaicsDatum[] = JSON.parse(raw('../data/naics_2017.json'));\n\nconst colorMap = [\n  { id: '0', color: '#A973BE' },\n  { id: '1', color: '#F1866C' },\n  { id: '2', color: '#FFC135' },\n  { id: '3', color: '#93CFD0' },\n  { id: '4', color: '#488098' },\n  { id: '5', color: '#77C898' },\n  { id: '6', color: '#6A6AAD' },\n  { id: '7', color: '#D35162' },\n  { id: '8', color: '#F28188' },\n]\n\nconst width = 800;\nconst height = 600;\n\ninterface PreparedDatum {\n  id: string,\n  title: string,\n  value: number,\n  topLevelParentId: string,\n}\n\n////////////////////////////////\n// interface RawDatum {\n//   id: number,\n//   city_id: number,\n//   year: number,\n//   naics_id: number,\n//   num_employ: number,\n//   num_company: number,\n//   level: number,\n// }\n// const rawData: RawDatum[][]  = [\n//   JSON.parse(raw('../data/boston_naics_sample/boston_sample_naics_1.json')),\n//   JSON.parse(raw('../data/boston_naics_sample/boston_sample_naics_2.json')),\n//   JSON.parse(raw('../data/boston_naics_sample/boston_sample_naics_3.json')),\n//   JSON.parse(raw('../data/boston_naics_sample/boston_sample_naics_4.json')),\n//   JSON.parse(raw('../data/boston_naics_sample/boston_sample_naics_5.json')),\n//   JSON.parse(raw('../data/boston_naics_sample/boston_sample_naics_6.json')),\n// ]\n\n// const data: PreparedDatum[][] = rawData.map(d => d.map(({naics_id, num_company}) => {\n//   let topLevelParentId: string = naics_id.toString();\n//   let current: NaicsDatum | undefined = naicsData.find(datum => datum.naics_id === naics_id);\n//   const title = current && current.name ? current.name : 'Unknown';\n//   while(current && current.parent_id !== null) {\n//     // eslint-disable-next-line\n//     current = naicsData.find(datum => datum.naics_id === (current as NaicsDatum).parent_id);\n//     if (current && current.parent_id !== null) {\n//       topLevelParentId = current.parent_id.toString();\n//     } else if (current && current.naics_id !== null) {\n//       topLevelParentId = current.naics_id.toString();\n//      }\n//   }\n//   if (parseInt(topLevelParentId, 10) > 8) {\n//     console.error(current);\n//     throw new Error('Parent out of range')\n//   }\n\n//   return {\n//     id: naics_id.toString(),\n//     title,\n//     value: num_company,\n//     topLevelParentId,\n//   }\n// }));\n\n// const transformedData: TransformedData[] = data.map(d => transformData({\n//   data: d,\n//   width,\n//   height,\n//   colorMap: colorMap,\n// }))\n//////////////////////////////////////\n\n\ninterface RawDatum {\n  city_id: 945 | 1022,\n  name: \"New York\" | \"Boston\",\n  naics_id: number,\n  level: 1 | 2 | 3 | 4 | 5 | 6,\n  year: 2019 | 2020,\n  num_company: number,\n  num_employ: number,\n}\n\nconst rawData: RawDatum[] = JSON.parse(raw('../data/bos_nyc_extract.json'));\n\ninterface DataMap {\n  [key: number]: PreparedDatum[]\n}\n\nconst bosData: DataMap = {\n  1: [],\n  2: [],\n  3: [],\n  4: [],\n  5: [],\n  6: [],\n}\nconst nyData: DataMap = {\n  1: [],\n  2: [],\n  3: [],\n  4: [],\n  5: [],\n  6: [],\n}\nlet bostonTotal = 0;\nlet newYorkTotal = 0;\nrawData.forEach(({naics_id, num_company, level, city_id, year}) => {\n  if (year === 2020) {\n    let topLevelParentId: string = naics_id.toString();\n    let current: NaicsDatum | undefined = naicsData.find(datum => datum.naics_id === naics_id);\n    const title = current && current.name ? current.name : 'Unknown';\n    while(current && current.parent_id !== null) {\n      // eslint-disable-next-line\n      current = naicsData.find(datum => datum.naics_id === (current as NaicsDatum).parent_id);\n      if (current && current.parent_id !== null) {\n        topLevelParentId = current.parent_id.toString();\n      } else if (current && current.naics_id !== null) {\n        topLevelParentId = current.naics_id.toString();\n      }\n    }\n    if (parseInt(topLevelParentId, 10) > 8) {\n      console.error(current);\n      throw new Error('Parent out of range')\n    }\n    if (city_id === 1022) {\n      bosData[level].push({\n        id: naics_id.toString() + level,\n        title,\n        value: num_company,\n        topLevelParentId,\n      })\n      bostonTotal += num_company;\n    } else {\n      nyData[level].push({\n        id: naics_id.toString() + level,\n        title,\n        value: num_company,\n        topLevelParentId,\n      })\n      newYorkTotal += num_company;\n    }\n  }\n});\n\nconst transformedBosData: TransformedData[] = [];\nconst transformedNyData: TransformedData[] = [];\nconst comparisonData: TransformedData[] = [];\n\nfor (let d in bosData) {\n  transformedBosData.push(transformData({\n    data: bosData[d],\n    width,\n    height,\n    colorMap: colorMap,\n  }))\n  transformedNyData.push(transformData({\n    data: nyData[d],\n    width,\n    height,\n    colorMap: colorMap,\n  }))\n  comparisonData.push(transformData({\n      // eslint-disable-next-line\n    data: bosData[d].map(d => ({...d, value: d.value / bostonTotal})),\n      // eslint-disable-next-line\n    comparisonData: nyData[d].map(d => ({...d, value: d.value / newYorkTotal})),\n    width,\n    height,\n    colorMap: colorMap,\n  }))\n}\n\n//////////////////////////////////////\n\nenum City {\n  Boston = 'Boston',\n  NewYork = 'New York',\n  Comparison = 'Comparison',\n}\n\n\nenum NumCellsTier {\n  // Use `Small` for all type of tree maps except for product tree maps at\n  // 6-digit detail level:\n  Small,\n  Large,\n}\n\nconst App = () => {\n  const [city, setCity] = useState<City>(City.Boston);\n  const [digit, setDigit] = useState<number>(0);\n\n  const tooltipContent = (id: string) => {\n    const current: NaicsDatum | undefined = naicsData.find(datum => datum.naics_id.toString() === id);\n    if (current) {\n      return current.name;\n    } else {\n      return id;\n    }\n  }\n\n  let dataset: TransformedData[] = [] \n  if (city === City.Boston) {\n    dataset = transformedBosData;\n  } else if (city === City.NewYork) {\n    dataset = transformedNyData;\n  } else {\n    dataset = comparisonData;\n  }\n\n  return (\n    <div>\n      <Nav>\n        <Button\n          onClick={() => setCity(City.Boston)}\n          disabled={city === City.Boston}\n        >\n          Boston\n        </Button>\n        <Button\n          onClick={() => setCity(City.NewYork)}\n          disabled={city === City.NewYork}\n        >\n          New York\n        </Button>\n        <Button\n          onClick={() => setCity(City.Comparison)}\n          disabled={digit > 3 || city === City.Comparison}\n        >\n          Comparison\n        </Button>\n      </Nav>\n      <Nav>\n        <Button\n          onClick={() => setDigit(0)}\n          disabled={digit === 0}\n        >\n          1-digit\n        </Button>\n        <Button\n          onClick={() => setDigit(1)}\n          disabled={digit === 1}\n        >\n          2-digit\n        </Button>\n        <Button\n          onClick={() => setDigit(2)}\n          disabled={digit === 2}\n        >\n          3-digit\n        </Button>\n        <Button\n          onClick={() => setDigit(3)}\n          disabled={digit === 3}\n        >\n          4-digit\n        </Button>\n        <Button\n          onClick={() => setDigit(4)}\n          disabled={city === City.Comparison || digit === 4}\n        >\n          5-digit\n        </Button>\n        <Button\n          onClick={() => setDigit(5)}\n          disabled={city === City.Comparison || digit === 5}\n        >\n          6-digit\n        </Button>\n      </Nav>\n      <h3>{city}: {digit + 1}-digit</h3>\n      <Container>\n        <TreeMap\n          highlighted={undefined}\n          cells={dataset[digit].treeMapCells}\n          numCellsTier={NumCellsTier.Small}\n          chartContainerWidth={width}\n          chartContainerHeight={height}\n          onCellClick={id => alert('Clicked: ' + tooltipContent(id))}\n          onMouseOverCell={id => console.log('Hovered on: ' + tooltipContent(id))}\n          onMouseLeaveChart={() => {}}\n          comparisonTreeMap={city === City.Comparison ? true : false}\n        />\n      </Container>\n    </div>\n  );\n}\n\nexport default App\n","import React, {useState} from 'react'\nimport raw from 'raw.macro';\nimport TreeMap, {\n  transformData\n} from 'react-canvas-treemap';\n\nconst colorMap = [\n  { id: '0', color: '#A973BE' },\n  { id: '1', color: '#F1866C' },\n  { id: '2', color: '#FFC135' },\n  { id: '3', color: '#93CFD0' },\n  { id: '4', color: '#488098' },\n  { id: '5', color: '#77C898' },\n  { id: '6', color: '#6A6AAD' },\n  { id: '7', color: '#D35162' },\n  { id: '8', color: '#F28188' },\n]\n\ninterface NaicsDatum {\n  naics_id: number,\n  code: string,\n  name: string,\n  level: number,\n  parent_id: number | null,\n  parent_code: string | null,\n  code_hierarchy: string,\n  naics_id_hierarchy: string,\n}\n\nconst naicsData: NaicsDatum[] = JSON.parse(raw('../data/naics_2017.json'));\n\ninterface RawDatum {\n  id: string,\n  title: string,\n  value: number,\n  topLevelParentId: string,\n}\n\nlet bostonTotal = 0;\nconst bostonData: RawDatum[] = [];\nJSON.parse(raw('../data/boston-3digit-shares.json'))\n  .forEach(({naics_id, num_employ}: {naics_id: number, num_employ: number}) => {\n    const industry = naicsData.find(d => d.naics_id === naics_id);\n    let topLevelParentId: string = naics_id.toString();\n    let current: NaicsDatum | undefined = naicsData.find(datum => datum.naics_id === naics_id);\n    while(current && current.parent_id !== null) {\n      // eslint-disable-next-line\n      current = naicsData.find(datum => datum.naics_id === (current as NaicsDatum).parent_id);\n      if (current && current.parent_id !== null) {\n        topLevelParentId = current.parent_id.toString();\n      } else if (current && current.naics_id !== null) {\n        topLevelParentId = current.naics_id.toString();\n      }\n    }\n    if (parseInt(topLevelParentId, 10) > 8) {\n      console.error(current);\n      throw new Error('Parent out of range')\n    }\n    if (industry) {\n      bostonTotal += num_employ;\n      bostonData.push({\n        id: naics_id.toString(),\n        title: industry.name,\n        value: num_employ,\n        topLevelParentId,\n      })\n    }\n  });\n\nlet newYorkTotal = 0;\nconst newYorkData: RawDatum[] = [];\nJSON.parse(raw('../data/newyork-3digit-shares.json'))\n  .forEach(({naics_id, num_employ}: {naics_id: number, num_employ: number}) => {\n    const industry = naicsData.find(d => d.naics_id === naics_id);\n    let topLevelParentId: string = naics_id.toString();\n    let current: NaicsDatum | undefined = naicsData.find(datum => datum.naics_id === naics_id);\n    while(current && current.parent_id !== null) {\n      // eslint-disable-next-line\n      current = naicsData.find(datum => datum.naics_id === (current as NaicsDatum).parent_id);\n      if (current && current.parent_id !== null) {\n        topLevelParentId = current.parent_id.toString();\n      } else if (current && current.naics_id !== null) {\n        topLevelParentId = current.naics_id.toString();\n      }\n    }\n    if (parseInt(topLevelParentId, 10) > 8) {\n      console.error(current);\n      throw new Error('Parent out of range')\n    }\n    if (industry) {\n      newYorkTotal += num_employ;\n      newYorkData.push({\n        id: naics_id.toString(),\n        title: industry.name,\n        value: num_employ,\n        topLevelParentId,\n      })\n    }\n  });\n\nconst width = 800;\nconst height = 600;\n\nconst transformedData = transformData({\n  data: bostonData,\n  comparisonData: newYorkData,\n  width,\n  height,\n  colorMap,\n});\n\nconst transformedPercentData = transformData({\n  data: bostonData.map(d => ({...d, value: d.value / bostonTotal})),\n  comparisonData: newYorkData.map(d => ({...d, value: d.value / newYorkTotal})),\n  width,\n  height,\n  colorMap,\n});\n\nenum NumCellsTier {\n  // Use `Small` for all type of tree maps except for product tree maps at\n  // 6-digit detail level:\n  Small,\n  Large,\n}\n\nconst App = () => {\n  const [filtered, setFiltered] = useState<boolean>(false);\n  return (\n    <div style={{display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh', flexDirection: 'column'}}>\n      <div style={{marginBottom: '2rem', display: 'flex', justifyContent: 'center', alignItems: 'center'}}>\n        <h4 style={{marginRight: '1rem'}}>Comparison of {filtered ? 'share percentages' : 'absolute values'}</h4>\n        <button onClick={() => setFiltered(!filtered)}>\n          {filtered ? 'Switch to absolute values' : 'Switch to share percentages'}\n        </button>\n      </div>\n      <TreeMap\n        highlighted={undefined}\n        cells={!filtered ? transformedData.treeMapCells : transformedPercentData.treeMapCells}\n        numCellsTier={NumCellsTier.Small}\n        chartContainerWidth={width}\n        chartContainerHeight={height}\n        onCellClick={id => console.log(id)}\n        onMouseOverCell={id => console.log(id)}\n        onMouseLeaveChart={() => {}}\n        comparisonTreeMap={true}\n      />\n    </div>\n  );\n}\n\nexport default App\n","import React from 'react'\nimport {\n  HashRouter as Router,\n  Route,\n  Switch,\n} from 'react-router-dom';\nimport Landing from './pages/Landing';\nimport ToggleDemo from './pages/ToggleDemo';\nimport DigitDemo from './pages/DigitDemo';\nimport ComparisonDemo from './pages/ComparisonDemo';\n\nconst App = () => {\n\n  return (\n    <div>\n      <Router>\n          <Switch>\n              <Route exact path={'/toggle'} component={ToggleDemo} />\n              <Route exact path={'/digit'} component={DigitDemo} />\n              <Route exact path={'/compare'} component={ComparisonDemo} />\n            <Route component={Landing} />\n          </Switch>\n        </Router>\n    </div>\n  );\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}